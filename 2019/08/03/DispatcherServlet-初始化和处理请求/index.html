<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="SpringMVC,">





  <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">






<meta name="description" content="DispatcherServlet初始化和处理请求DispatcherServlet 是前端控制器设计模式的实现，提供 Spring Web MVC 集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成。  （1）DispatcherServlet 实现了 HttpServlet 接口，因此，DispatcherServlet 是一个 Servlet，那么它就遵循 Servl">
<meta name="keywords" content="SpringMVC">
<meta property="og:type" content="article">
<meta property="og:title" content="DispatcherServlet 初始化和处理请求">
<meta property="og:url" content="http://yoursite.com/2019/08/03/DispatcherServlet-初始化和处理请求/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="DispatcherServlet初始化和处理请求DispatcherServlet 是前端控制器设计模式的实现，提供 Spring Web MVC 集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成。  （1）DispatcherServlet 实现了 HttpServlet 接口，因此，DispatcherServlet 是一个 Servlet，那么它就遵循 Servl">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/70dc5b5cgy1g4xfga5wx8j20pp0gbaae.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/70dc5b5cgy1g5ce26fs38j20ox0nejx4.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/70dc5b5cgy1g5mkycs1akj20um0hzjs3.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/70dc5b5cgy1g4ybsyz3scj20pp0gbaae.jpg">
<meta property="og:updated_time" content="2019-08-03T12:37:13.683Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DispatcherServlet 初始化和处理请求">
<meta name="twitter:description" content="DispatcherServlet初始化和处理请求DispatcherServlet 是前端控制器设计模式的实现，提供 Spring Web MVC 集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成。  （1）DispatcherServlet 实现了 HttpServlet 接口，因此，DispatcherServlet 是一个 Servlet，那么它就遵循 Servl">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/70dc5b5cgy1g4xfga5wx8j20pp0gbaae.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/03/DispatcherServlet-初始化和处理请求/">





  <title>DispatcherServlet 初始化和处理请求 | 个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/03/DispatcherServlet-初始化和处理请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuoshangan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">DispatcherServlet 初始化和处理请求</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-03T20:34:45+08:00">
                2019-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="DispatcherServlet初始化和处理请求"><a href="#DispatcherServlet初始化和处理请求" class="headerlink" title="DispatcherServlet初始化和处理请求"></a>DispatcherServlet初始化和处理请求</h1><p>DispatcherServlet 是前端控制器设计模式的实现，提供 Spring Web MVC 集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成。</p>
<p><img src="https://ws1.sinaimg.cn/large/70dc5b5cgy1g4xfga5wx8j20pp0gbaae.jpg" alt></p>
<p>（1）DispatcherServlet 实现了 HttpServlet 接口，因此，DispatcherServlet 是一个 Servlet，那么它就遵循 Servlet 的生命周期；</p>
<p>（2）DispatcherServlet 还实现 Aware接口，Spring 会自动注入 Aware 接口方法里的对象；但是 DispatcherServlet 对象由 Web 容器来管理，而不是由 Spring IOC 管理，因此，根本就不可能自动注入Environment 和 ApplicationContext 对象；这里的 ApplicationContextAware 和 EnvironmentAware 实际是作为普通接口使用，需要手动编程调用接口方法，如果 ServletContext.addServlet 方法注入 Servlet，如果注册的是 DispatcherServlet，那么就可以在 FrameworkServlet 及其子类通过构造方法时传入已经创建好的 WebApplicationContext；默认使用  WebApplicationContext 作为上下文，Spring默认配置文件为 “/WEBINF/[servlet名字]-servlet.xml“ </p>
<p>（3）实现 EnvironmentCapacle 接口，表示 DispatcherServlet 具有 Environment 的能力，也就是可以提供 Environment，这是通过 getEnvironment() 方法获取</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnvironmentCapable</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回Environment对象</span></span><br><span class="line">	<span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>DispatcherServlet 主要用作职责调度工作，本身主要用于控制流程，主要职责如下：</p>
<p>1、文件上传解析，如果请求类型是 multipart 将通过 MultipartResolver 进行文件上传解析；</p>
<p>2、通过 HandlerMapping 将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor 拦截器）；</p>
<p>3、通过 HandlerAdapter 支持多种类型的处理器(HandlerExecutionChain 中的处理器)；</p>
<p>4、通过 ViewResolver 解析逻辑视图名到具体视图实现；</p>
<p>5、本地化解析；</p>
<p>6、渲染具体的视图等；</p>
<p>7、如果执行过程中遇到异常将交给 HandlerExceptionResolver 来解析；</p>
<p>DispatcherServlet 的初始化和处理请求的流程图如下所示：</p>
<p><img src="https://ws1.sinaimg.cn/large/70dc5b5cgy1g5ce26fs38j20ox0nejx4.jpg" alt></p>
<p>图片来源阿里大神博客[<a href="http://fangjian0423.github.io/2017/07/28/springmvc-process-write-by-processon/" target="_blank" rel="noopener">http://fangjian0423.github.io/2017/07/28/springmvc-process-write-by-processon/</a>]</p>
<h2 id="DispatcherServlet中使用的特殊Bean"><a href="#DispatcherServlet中使用的特殊Bean" class="headerlink" title="DispatcherServlet中使用的特殊Bean"></a>DispatcherServlet中使用的特殊Bean</h2><p>DispatcherServlet 默认使用 WebApplicationContext 作为上下文，WebApplicationContext 上下文中有如下的特殊 bean：</p>
<p>1、Controller：处理器/页面控制器，做的是 MVC 中的 C 的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理；</p>
<p>2、HandlerMapping：请求到处理器的映射，如果映射成功返回一个 HandlerExecutionChain 对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器；</p>
<p>3、HandlerAdapter：HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理；</p>
<p>4、ViewResolver：ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为 jsp 视图；</p>
<p>5、LocalResover：本地化解析，因为Spring支持国际化，因此LocalResover解析客户端的Locale信息从而方便进行国际化；</p>
<p>6、ThemeResovler：主题解析，通过它来实现一个页面多套风格，即常见的类似于软件皮肤效果；</p>
<p>7、MultipartResolver：文件上传解析，用于支持文件上传；</p>
<p>8、HandlerExceptionResolver：处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息）；</p>
<p>9、RequestToViewNameTranslator：当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名；</p>
<p>10、FlashMapManager：用于管理FlashMap的策略接口，FlashMap用于存储一个请求的输出，当进入另一个请求时作为该请求的输入，通常用于重定向场景。</p>
<h1 id="DispatcherServlet-初始化"><a href="#DispatcherServlet-初始化" class="headerlink" title="DispatcherServlet 初始化"></a>DispatcherServlet 初始化</h1><p>从 DispatcherServlet 的类图中可以看出，DispatcherServlet 是一个 Servlet，那么它就会遵从 Servlet 的规范，在初始化时会调用 Servlet 的 init 方法，本小节就从 Servlet#init 方法触发分析 DispatcherServlet 的初始化流程</p>
<h2 id="基于-xml-配置文件整合"><a href="#基于-xml-配置文件整合" class="headerlink" title="基于 xml 配置文件整合"></a>基于 xml 配置文件整合</h2><p>下面是使用 xml 配置文件时 web.xml 文件的配置：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- Spring上下文参数 --></span>  </span><br><span class="line"><span class="tag"><<span class="name">context-param</span>></span>  </span><br><span class="line">    <span class="tag"><<span class="name">param-name</span>></span>contextConfigLocation<span class="tag">param-name</span>></span>  <br><span class="line">    <span class="tag"><<span class="name">param-value</span>></span>classpath:spring-context.xml<span class="tag">param-value</span>></span>  <br><span class="line"><span class="tag">context-param</span>></span>  <br><span class="line"></span><br><span class="line"><span class="comment"><!-- 监听Spring容器启动--></span>  </span><br><span class="line"><span class="tag"><<span class="name">listener</span>></span>  </span><br><span class="line">    <span class="tag"><<span class="name">listener-class</span>></span>org.springframework.web.context.ContextLoaderListener<span class="tag">listener-class</span>></span>  <br><span class="line"><span class="tag">listener</span>></span>  <br><span class="line"></span><br><span class="line"><span class="comment"><!-- Spring MVC --></span></span><br><span class="line"><span class="tag"><<span class="name">servlet</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">servlet-name</span>></span>springmvc<span class="tag">servlet-name</span>></span><br><span class="line">    <span class="tag"><<span class="name">servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class="tag">servlet-class</span>></span><br><span class="line">    <span class="tag"><<span class="name">load-on-startup</span>></span>1<span class="tag">load-on-startup</span>></span><br><span class="line">    <span class="tag"><<span class="name">init-param</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">param-name</span>></span>contextConfigLocation<span class="tag">param-name</span>></span><br><span class="line">        <span class="tag"><<span class="name">param-value</span>></span>classpath:spring-servlet-config.xml<span class="tag">param-value</span>></span><br><span class="line">    <span class="tag">init-param</span>></span><br><span class="line"><span class="tag">servlet</span>></span><br><span class="line"><span class="tag"><<span class="name">servlet-mapping</span>></span>  </span><br><span class="line">    <span class="tag"><<span class="name">servlet-name</span>></span>springmvc<span class="tag">servlet-name</span>></span>  <br><span class="line">    <span class="tag"><<span class="name">url-pattern</span>></span>/<span class="tag">url-pattern</span>></span>  <br><span class="line"><span class="tag">servlet-mapping</span>></span><br></pre></td></tr></tbody></table></figure>

<p>其中，load-on-startup 的值（默认值为 0，）设置为 1，表示启动容器时初始化该 Servlet，数字表示容器初始化 Servlet 的顺序，值越小优先级越高，也就是说，loan-on-startup 的值越小，容器优先初始化该 Servlet。</p>
<p>URL 模式设置为 “/“ 时，所有的请求（包含静态资源）都会被映射到 DispatcherServlet，为了能正确处理静态资源，需要在 Spring MVC 配置文件中添加 <mvc:resources>  标签来指明静态文件</mvc:resources></p>
<p>Spring MVC 的配置文件为：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.spring"</span>/></span></span><br><span class="line"><span class="tag"><<span class="name">mvc:annotation-driven</span> /></span></span><br><span class="line"><span class="tag"><<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/css/"</span> /></span></span><br><span class="line"><span class="tag"><<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/*.html"</span> <span class="attr">location</span>=<span class="string">"/"</span> /></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /></span></span><br><span class="line">    <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /></span></span><br><span class="line"><span class="tag">bean</span>></span><br></pre></td></tr></tbody></table></figure>

<p><strong><annotation-driven> 元素会注册控制器注解的 bean ，<resources> 元素表示哪些静态资源需要单独处理；</resources></annotation-driven></strong>如果没有 <annotation-driven> ，<resources> 元素会阻止任意控制器被调用，因此，如果不需要使用 resource，则不需要  <annotation-driven> 元素。</annotation-driven></resources></annotation-driven></p>
<h2 id="默认策略组件"><a href="#默认策略组件" class="headerlink" title="默认策略组件"></a>默认策略组件</h2><p>在DispatcherServlet 中 defaultStrategies 字段存储了所有的默认策略组件，这些默认的策略组件在 DispatcherServlet 加载时就会读取 DispatcherServlet.properties 属性文件的内容，然后将其设置到 defaultStrategies 对象中</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"DispatcherServlet.properties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="comment">// 静态方法中读取DispatcherServlet.properties属性文件，并设置到defaultStrategies对象中</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(</span><br><span class="line">            DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</span><br><span class="line">        defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH</span><br><span class="line">                                        + <span class="string">"': "</span> + ex.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>DispatcherServlet.properties 配置文件，配置了 SpringMVC 需要使用的默认策略组件，当没有配置 <mvc:annotation-driven> 标签时，这些默认配置才会生效，当配置已经配置<mvc:annotation-driven> 标签，AnnotationDrivenBeanDefinitionParser 会创建某些策略组件，这些策略组件会覆盖默认的策略组件。</mvc:annotation-driven></mvc:annotation-driven></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Default implementation classes for DispatcherServlet's strategy interfaces.</span><br><span class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span><br><span class="line"># Not meant to be customized by application developers.</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></tbody></table></figure>

<p>DispatcherServlet 也可以配置自己的初始化参数，覆盖默认配置：</p>
<p>1、contextClass：实现 WebApplicationContext 接口的类，当前的 Servlet 用它来创建上下文，如果没有指定 contextClass 参数，默认使用 XmlWebApplicationContext；</p>
<p>2、contextConfigLocation：指定上下文的位置，上下文实例（contextClass指定）的字符串，可以指定多个上下文，多个上下文使用逗号进行分割；</p>
<p>3、namespace：WebApplicationContext 命名空间，默认值是 “[server-name]-servlet”。</p>
<h2 id="获取默认的策略组件"><a href="#获取默认的策略组件" class="headerlink" title="获取默认的策略组件"></a>获取默认的策略组件</h2><p>从DispatcherServlet.properties 文件中可以看到有些策略组件有一个默认的实现，也有的组件有多个默认的实现，因此，在 DispatcherServlet 中提供了两个方法用于获取默认的策略组件：获取单个策略组件的 getDefaultStrategy 方法、获取多个策略组件的 getDefaultStrategies 方法。</p>
<p>获取单个策略组件的 getDefaultStrategy 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <t> <span class="function">T <span class="title">getDefaultStrategy</span><span class="params">(ApplicationContext context,</span></span></t></span><br><span class="line"><span class="function"><span class="params">                                   Class<t> strategyInterface)</t></span> </span>{</span><br><span class="line">    <span class="comment">// 获取默认的策略组件</span></span><br><span class="line">    List<t> strategies = getDefaultStrategies(context, strategyInterface);</t></span><br><span class="line">    <span class="keyword">if</span> (strategies.size() != <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span><br><span class="line">            <span class="string">"DispatcherServlet needs exactly 1 strategy for interface ["</span></span><br><span class="line">            + strategyInterface.getName() + <span class="string">"]"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> strategies.get(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>获取多个策略组件 getDefaultStrategies 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <t> <span class="function">List<t> <span class="title">getDefaultStrategies</span><span class="params">(ApplicationContext context,</span></t></span></t></span><br><span class="line"><span class="function"><span class="params">                                           Class<t> strategyInterface)</t></span> </span>{</span><br><span class="line">    String key = strategyInterface.getName();</span><br><span class="line">    <span class="comment">// 获取策略组件的类型</span></span><br><span class="line">    String value = defaultStrategies.getProperty(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 存在多个策略组件实现类</span></span><br><span class="line">        String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">        List<t> strategies = <span class="keyword">new</span> ArrayList<>(classNames.length);</t></span><br><span class="line">        <span class="comment">// 遍历所有的实现类</span></span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 获取策略实现类的类名</span></span><br><span class="line">                Class<?> clazz = ClassUtils.forName(</span><br><span class="line">                    className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">                <span class="comment">// 根据BeanDefinition进行实例</span></span><br><span class="line">                Object strategy = createDefaultStrategy(context, clazz);</span><br><span class="line">                strategies.add((T) strategy);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span><br><span class="line">                    <span class="string">"Could not find DispatcherServlet's default strategy class ["</span></span><br><span class="line">                    + className + <span class="string">"] for interface ["</span> + key + <span class="string">"]"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (LinkageError err) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span><br><span class="line">                    <span class="string">"Unresolvable class definition for DispatcherServlet's"</span></span><br><span class="line">                    + <span class="string">" default strategy class ["</span> + className </span><br><span class="line">                    + <span class="string">"] for interface ["</span> + key + <span class="string">"]"</span>, err);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> strategies;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList<>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="HttpServletBean-init"><a href="#HttpServletBean-init" class="headerlink" title="HttpServletBean.init"></a>HttpServletBean.init</h2><p>HttpServletBean 继承 HttpServlet 抽象类，继承 HttpServlet大部分的默认行为， HttpServletBean 主要作用<font color="red"> 在 Web 容器启动时将调用它的 init 方法，将 DispatcherServlet 初始化参数（init-param）使用 BeanWrapper 设置到 DispatcherServlet 组件上，在初始化时将 DispatcherServlet  中的 <servlet> 标签的 <init-param> 子标签当做一个 bean；</init-param></servlet></font><init-param> 标签用于设置 Servlet 的初始化参数，可以通过 getInitParameter(String name) 方法获取对应的初始化参数；它并没有处理请求，而是将请求处理留给子类实现。</init-param></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">		logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （1）将Servlet初始化参数设置到PropertyValue对象</span></span><br><span class="line">	PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(),</span><br><span class="line">				<span class="keyword">this</span>.requiredProperties);</span><br><span class="line">	<span class="keyword">if</span> (!pvs.isEmpty()) {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">			<span class="comment">// 加载资源</span></span><br><span class="line">            ResourceLoader resourceLoader =</span><br><span class="line">                <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">			bw.registerCustomEditor(Resource.class,</span><br><span class="line">				<span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">            <span class="comment">// 模板方法，可以在子类中调用，做初始化工作</span></span><br><span class="line">			initBeanWrapper(bw);</span><br><span class="line">            <span class="comment">// 将配置的初始化值设置到DispatcherServlet</span></span><br><span class="line">			bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">			<span class="keyword">if</span> (logger.isErrorEnabled()) {</span><br><span class="line">				logger.error(<span class="string">"Failed to set bean properties on servlet '"</span></span><br><span class="line">					+ getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （2）提供给子类初始化的扩展点，该方法由FrameworkServlet覆盖</span></span><br><span class="line">	initServletBean();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">		logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>BeanWrapper 是 Spring 用来操作 Java bean 的工具类，可以直接修改 Java bean 的属性，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServletConfigPropertyValues</span><span class="params">(ServletConfig config, Set<string> requiredProperties)</string></span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line"></span><br><span class="line">    Set<string> missingProps = (!CollectionUtils.isEmpty(requiredProperties)</string></span><br><span class="line">                       ? <span class="keyword">new</span> HashSet<string>(requiredProperties) : <span class="keyword">null</span>);</string></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Servlet的初始化参数</span></span><br><span class="line">    Enumeration<string> paramNames = config.getInitParameterNames();</string></span><br><span class="line">    <span class="keyword">while</span> (paramNames.hasMoreElements()) {</span><br><span class="line">        String property = paramNames.nextElement();</span><br><span class="line">        Object value = config.getInitParameter(property);</span><br><span class="line">        <span class="comment">// 初始化参数封装成PropertyValue对象</span></span><br><span class="line">        addPropertyValue(<span class="keyword">new</span> PropertyValue(property, value));</span><br><span class="line">        <span class="keyword">if</span> (missingProps != <span class="keyword">null</span>) {</span><br><span class="line">            missingProps.remove(property);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化失败</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(missingProps)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(</span><br><span class="line">            <span class="string">"Initialization from ServletConfig for servlet '"</span> + config.getServletName() +</span><br><span class="line">            <span class="string">"' failed; the following required properties were missing: "</span> +</span><br><span class="line">            StringUtils.collectionToDelimitedString(missingProps, <span class="string">", "</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="FrameworkServlet-initServletBean"><a href="#FrameworkServlet-initServletBean" class="headerlink" title="FrameworkServlet.initServletBean"></a>FrameworkServlet.initServletBean</h2><p>initServletBean() 方法时父类 HttpServletBean 提供的模板方法，它在 HttpServletBean的初始化入口方法 init() 方法中调用，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">    getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span></span><br><span class="line">                            + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) {</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName()</span><br><span class="line">                         + <span class="string">"': initialization started"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// (1)初始化Web应用上下文</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        <span class="comment">// (2)提供给子类初始化FrameworkServlet的模板方法</span></span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (ServletException ex) {</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) {</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) {</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName()</span><br><span class="line">                         + <span class="string">"': initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>FrameworkServlet.initServletBean() 方法的作用功能是完成如下两个方面的任务：</p>
<ul>
<li>初始化 WebApplicationContext；</li>
<li>提供一个模板方法 initFrameworkServlet() 方法初始化 FrameworkServlet，默认为空实现，由子类实现；</li>
</ul>
<h3 id="初始化-WebApplicationContext"><a href="#初始化-WebApplicationContext" class="headerlink" title="初始化 WebApplicationContext"></a>初始化 WebApplicationContext</h3><p>其中，WebApplicationContext 表示 Web 环境的上下文对象，初始化 web 上下文为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// (1)使用ContextLoaderListener所加载的根上下文</span></span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// (2)使用Servlet构造函数注册的Web应用上下文</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) {</span><br><span class="line">            ConfigurableWebApplicationContext cwac =</span><br><span class="line">                (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) {</span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) {</span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                }</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// (3)使用contextAttribute值指定的ServletContext上下文中的Web应用上下文</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// (4)DispatcherServlet中init-param指定的contextConfigLocation所加载的Web应用上下文</span></span><br><span class="line">        <span class="comment">// 如果没有找到相应的上下文，并指定父亲为ContextLoaderListener加载的Web应用上下文</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContextRefreshEvent还没触发则刷新容器</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) {</span><br><span class="line">        <span class="comment">// (5)刷新上下文（初始化SpringMVC的基础组件），由子类（DispatcherServlet）实现</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) {</span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) {</span><br><span class="line">        <span class="comment">// (6)将Web应用上下文，存储在ServletContext上下文中</span></span><br><span class="line">        <span class="comment">// 这里的</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><font color="red">注意：这里的 Web 应用上下文，指的是 Spring 的 WebApplicationContext 对象</font></p>
<p>从 initWebApplicationContext() 方法的主要作用为：</p>
<ul>
<li>获取 ContextLoaderListener 加载的 Spring 根容器 rootContext；</li>
<li>设置 WebApplicationContext，如果 ContextRefreshedEvent 事件还没触发则调用 onRefresh() 方法刷新容器；</li>
<li>将 WebApplicationContext 对象作为 ServletContext 一个属性设置到 ServletContext 中，方便在后续中获取 Spring 容器。</li>
</ul>
<p>基本上如果 ContextLoaderListener 加载了上下文将作为根上下文（即 DispatcherServlet 的父容器）。</p>
<p>（1）获取 Spring 根容器 rootContext</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE =</span><br><span class="line">    WebApplicationContext.class.getName() + <span class="string">".ROOT"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getWebApplicationContext(sc,</span><br><span class="line">		WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title">getWebApplicationContext</span><span class="params">(ServletContext sc,</span></span></span><br><span class="line"><span class="function"><span class="params">		String attrName)</span> </span>{</span><br><span class="line">    Assert.notNull(sc, <span class="string">"ServletContext must not be null"</span>);</span><br><span class="line">    <span class="comment">// 从ServletContext中获取</span></span><br><span class="line">    Object attr = sc.getAttribute(attrName);</span><br><span class="line">    <span class="keyword">if</span> (attr == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (attr <span class="keyword">instanceof</span> RuntimeException) {</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) attr;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (attr <span class="keyword">instanceof</span> Error) {</span><br><span class="line">        <span class="keyword">throw</span> (Error) attr;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (attr <span class="keyword">instanceof</span> Exception) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException((Exception) attr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!(attr <span class="keyword">instanceof</span> WebApplicationContext)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">			<span class="string">"Context attribute is not of type WebApplicationContext: "</span> + attr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (WebApplicationContext) attr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到获取根容器 rootContext 是直接以 org.springframework.web.context.WebApplicationContext.ROOT 作为键从 ServletContext 中获取，也就是说默认情况下，Spring 的根容器为作为一个属性存储在 ServletContext中，它的键为 org.springframework.web.context.WebApplicationContext.ROOT；</p>
<p>（2）调用 onRefresh() 方法</p>
<p>创建 WebApplicationContext ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(WebApplicationContext parent)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>{</span><br><span class="line">    <span class="comment">// 在web.xml文件中指定DispatcherServlet的contextClass属性值</span></span><br><span class="line">    Class<?> contextClass = getContextClass();</span><br><span class="line">    <span class="comment">// 如果指定Web上下文不是ConfigurableWebApplicationContext子类则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line">            <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">    }</span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">	<span class="comment">// 设置环境</span></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置WebApplicationContext的父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">// 如果在web.xml文件中指定DispatcherServlet的contextConfigLocation属性值</span></span><br><span class="line">    String configLocation = getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) {</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    }</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建 WebApplicationContext 的三种方法：</p>
<ul>
<li>在 Servlet3.0 后通过 ServletContext.addServlet 注册 DispatcherServlet 时，在 DispatcherServlet 的构造方法中会创建 WebApplicationContext。</li>
<li>WebApplicationContext 已经存在 ServletConetxt 中，则通过 DispatcherServlet的contextAttribute 属性值获取 WebApplicationContext 对象</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">servlet</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">servlet-name</span>></span>dispatcherServlet<span class="tag">servlet-name</span>></span><br><span class="line">    <span class="tag"><<span class="name">servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class="tag">servlet-class</span>></span><br><span class="line">    <span class="tag"><<span class="name">load-on-startup</span>></span>1<span class="tag">load-on-startup</span>></span><br><span class="line">    <span class="tag"><<span class="name">init-param</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">param-name</span>></span>contextAttribute<span class="tag">param-name</span>></span><br><span class="line">        <span class="tag"><<span class="name">param-value</span>></span>springmvc<span class="tag">param-value</span>></span><br><span class="line">    <span class="tag">init-param</span>></span><br><span class="line"><span class="tag">servlet</span>></span><br><span class="line"><span class="tag"><<span class="name">servlet-mapping</span>></span>  </span><br><span class="line">    <span class="tag"><<span class="name">servlet-name</span>></span>springmvc<span class="tag">servlet-name</span>></span>  <br><span class="line">    <span class="tag"><<span class="name">url-pattern</span>></span>/<span class="tag">url-pattern</span>></span>  <br><span class="line"><span class="tag">servlet-mapping</span>></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>在前面两种方法都没有创建 WebApplicationContext 时调用 createWebApplicationContext 方法创建 WebApplicationContext ：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(WebApplicationContext parent)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>{</span><br><span class="line">    <span class="comment">// 在web.xml文件中指定DispatcherServlet的contextClass属性值</span></span><br><span class="line">    Class<?> contextClass = getContextClass();</span><br><span class="line">    <span class="comment">// 如果指定Web上下文不是ConfigurableWebApplicationContext子类则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line">            <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">    }</span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">	<span class="comment">// 设置环境</span></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置WebApplicationContext的父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">// 如果在web.xml文件中指定DispatcherServlet的contextConfigLocation属性值</span></span><br><span class="line">    String configLocation = getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) {</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    }</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    	ConfigurableWebApplicationContext wac)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) {</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -> assign a more useful id based on available information</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) {</span><br><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX</span><br><span class="line">                    + ObjectUtils.getDisplayString(getServletContext().getContextPath())</span><br><span class="line">                    + <span class="string">'/'</span> + getServletName());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wac.setServletContext(getServletContext());</span><br><span class="line">    wac.setServletConfig(getServletConfig());</span><br><span class="line">    wac.setNamespace(getNamespace());</span><br><span class="line">    <span class="comment">// 添加ContextRefreshedEvent事件监听器</span></span><br><span class="line">    wac.addApplicationListener(</span><br><span class="line">        <span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) {</span><br><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(</span><br><span class="line">            getServletContext(), getServletConfig());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    postProcessWebApplicationContext(wac);</span><br><span class="line">    applyInitializers(wac);</span><br><span class="line">    wac.refresh();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ContextRefreshedEvent事件监听器监听的是 ContextRefreshListener 事件，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextRefreshListener</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    	<span class="title">ApplicationListener</span><<span class="title">ContextRefreshedEvent</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>{</span><br><span class="line">        FrameworkServlet.<span class="keyword">this</span>.onApplicationEvent(event);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.refreshEventReceived = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) {</span><br><span class="line">        onRefresh(event.getApplicationContext());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当接受到消息时调用 FrameworkServlet 的 onApplicationEvent 方法，在 onApplicationEvent 方法中会将 refreshEventReceived 标识设置为true，然后调用 FrameworkServlet.onRefresh 方法，onRefresh() 方法是一个模板方法，只会被调用一次，DispatcherServlet 就是通过 onRefresh() 方法来完成初始化的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    initStrategies(context);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>（3）将 WebApplicationContext 设置到 ServletContext 中，</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>（1）使用 ContextLoaderListener 加载的 Web 应用上下文，是在 web.xml 中构造父子容器的常见方案</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- Spring上下文参数 --></span>  </span><br><span class="line"><span class="tag"><<span class="name">context-param</span>></span>  </span><br><span class="line">    <span class="tag"><<span class="name">param-name</span>></span>contextConfigLocation<span class="tag">param-name</span>></span>  <br><span class="line">    <span class="tag"><<span class="name">param-value</span>></span>classpath:spring-context.xml<span class="tag">param-value</span>></span>  <br><span class="line"><span class="tag">context-param</span>></span>  <br><span class="line"><span class="comment"><!-- 监听Spring容器启动--></span>  </span><br><span class="line"><span class="tag"><<span class="name">listener</span>></span>  </span><br><span class="line">    <span class="tag"><<span class="name">listener-class</span>></span>org.springframework.web.context.ContextLoaderListener<span class="tag">listener-class</span>></span>  <br><span class="line"><span class="tag">listener</span>></span><br></pre></td></tr></tbody></table></figure>

<p>（2）使用 Servlet 构造函数注册的 Web 应用上下文</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DispatcherServlet</span><span class="params">(WebApplicationContext webApplicationContext)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(webApplicationContext);</span><br><span class="line">    setDispatchOptionsRequest(<span class="keyword">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里调用父类的构造方法就是调用 FrameworkServlet 的构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FrameworkServlet</span><span class="params">(WebApplicationContext webApplicationContext)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.webApplicationContext = webApplicationContext;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>（3）使用 contextAttribute 属性值指定的 ServletContext 上下文中的 Web 应用上下文；这种方式比较少见。</p>
<p>从 ServletContext 上下文中去找一个 key 为 myWebApplicationContext 的 Web 应用上下文，来作为 DispatcherServlet 对象中的 webApplicationContext 属性的值，当然，前提是 ServletContext 上下文中放置过该 Web 应用上下文对象</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">servlet</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">servlet-name</span>></span>dispatcherServlet<span class="tag">servlet-name</span>></span><br><span class="line">    <span class="tag"><<span class="name">servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class="tag">servlet-class</span>></span><br><span class="line">    <span class="tag"><<span class="name">init-param</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">param-name</span>></span>contextAttribute<span class="tag">param-name</span>></span><br><span class="line">        <span class="tag"><<span class="name">param-value</span>></span>myWebApplicationContext<span class="tag">param-value</span>></span><br><span class="line">    <span class="tag">init-param</span>></span><br><span class="line">    <span class="tag"><<span class="name">load-on-startup</span>></span>1<span class="tag">load-on-startup</span>></span><br><span class="line"><span class="tag">servlet</span>></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用contextAttribute值指定的ServletContext上下文中的Web应用上下文</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">findWebApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    String attrName = getContextAttribute();</span><br><span class="line">    <span class="keyword">if</span> (attrName == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    WebApplicationContext wac = WebApplicationContextUtils</span><br><span class="line">        .getWebApplicationContext(getServletContext(), attrName);</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No WebApplicationContext found: initializer not registered?"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>（4）在 DispatcherServlet 中 init-param 指定的 contextConfigLocation 所加载的 Web 应用上下文，这种配置是比较常见的配置 Web 应用上下文 的方式：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">servlet</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">servlet-name</span>></span>springmvc<span class="tag">servlet-name</span>></span><br><span class="line">    <span class="tag"><<span class="name">servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class="tag">servlet-class</span>></span><br><span class="line">    <span class="tag"><<span class="name">load-on-startup</span>></span>1<span class="tag">load-on-startup</span>></span><br><span class="line">    <span class="tag"><<span class="name">init-param</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">param-name</span>></span>contextConfigLocation<span class="tag">param-name</span>></span><br><span class="line">        <span class="tag"><<span class="name">param-value</span>></span>classpath:spring-mvc.xml<span class="tag">param-value</span>></span><br><span class="line">    <span class="tag">init-param</span>></span><br><span class="line"><span class="tag">servlet</span>></span><br><span class="line"><span class="tag"><<span class="name">servlet-mapping</span>></span>  </span><br><span class="line">    <span class="tag"><<span class="name">servlet-name</span>></span>springmvc<span class="tag">servlet-name</span>></span>  <br><span class="line">    <span class="tag"><<span class="name">url-pattern</span>></span>/<span class="tag">url-pattern</span>></span>  <br><span class="line"><span class="tag">servlet-mapping</span>></span><br></pre></td></tr></tbody></table></figure>

<p>根据 contextConfigLocation 创建的 Web 应用上下文</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(WebApplicationContext parent)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>{</span><br><span class="line">    <span class="comment">// 获取<servlet-class>标签</servlet-class></span></span><br><span class="line">    Class<?> contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) {</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Servlet with name '"</span> + getServletName()</span><br><span class="line">                 + <span class="string">"' will try to create custom WebApplicationContext context of class '"</span></span><br><span class="line">                 + contextClass.getName() + <span class="string">"'"</span> + <span class="string">", using parent context ["</span></span><br><span class="line">                 + parent + <span class="string">"]"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line">            <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">	</span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">// 设置配置文件路径，即contextConfigLocation指定</span></span><br><span class="line">    wac.setConfigLocation(getContextConfigLocation());</span><br><span class="line"></span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) {</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -> assign a more useful id based on available information</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) {</span><br><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX</span><br><span class="line">                    + ObjectUtils.getDisplayString(getServletContext().getContextPath())</span><br><span class="line">                    + <span class="string">'/'</span> + getServletName());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wac.setServletContext(getServletContext());</span><br><span class="line">    wac.setServletConfig(getServletConfig());</span><br><span class="line">    wac.setNamespace(getNamespace());</span><br><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(</span><br><span class="line">        wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) {</span><br><span class="line">        ((ConfigurableWebEnvironment) env)</span><br><span class="line">        	.initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    postProcessWebApplicationContext(wac);</span><br><span class="line">    <span class="comment">// 执行web.xml中init-param指定的ApplicationContextInitializer的实现类初始化方法</span></span><br><span class="line">    applyInitializers(wac);</span><br><span class="line">    <span class="comment">// Spring容器的刷新方法</span></span><br><span class="line">    wac.refresh();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>wac.refresh() 是 Spring 容器的启动刷新方法，它会扫描 </p>
<p><context:component-scan base-package="”com.spring”/">  所指定目录下的 @Component、@Service、@Controller、@Repository、@Configuration所标注的类。</context:component-scan></p>
<p><font color="red">经过 （1）-（4）这四个步骤后 WebApplicationContext 就创建完毕了。</font></p>
<p>（5）初始化 Spring MVC 的基础组件</p>
<p>如果配置 <mvc:annotation-driven> 标签，则使用 <mvc:annotation-driven> 标签所绑定的 Spring MVC 基础组件；如果没有配置 <mvc:annotation-driven> 标签，则使用 DispatcherServlet.properties 配置文件内默认的 Spring MVC 基础组件 。</mvc:annotation-driven></mvc:annotation-driven></mvc:annotation-driven></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><font color="red">onRefresh 方法在 FrameworkServlet 中为空实现，具体地实现由 DispatcherServlet 实现。</font></p>
<p>（6）将 Web 应用上下文，存储在 ServletContext 上下文中</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVLET_CONTEXT_PREFIX =</span><br><span class="line">    FrameworkServlet.class.getName() + <span class="string">".CONTEXT."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletContextAttributeName</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> SERVLET_CONTEXT_PREFIX + getServletName();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 getServletName() 方法返回的就是 Servlet 的名称，这个名称使我们在 web.xml 文件里配置的，比如本例中存储在 ServeltContext 的 Web 应用上下文的 key 为</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.FrameworkServlet.CONTEXT.springmvc</span><br></pre></td></tr></tbody></table></figure>

<p>存储在 ServletContext 中的 Web 应用上下文可以通过 getAttribute(String name) 方法来获取，比如本例中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext wac = (WebApplicationContext) servletContext</span><br><span class="line">	.getAttribute(<span class="string">"org.springframework.web.servlet.FrameworkServlet.CONTEXT.springmvc"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>经过上面的六个步骤后</strong>，WebApplicationContext 对象存在于 DispatcherServlet 对象中，也存在于 ServletContext 上下文中，ServletContext对象，就是传说中的 global session，也就是 jsp 中的 application 对象。WebApplicationContext 上下文对象中，也存储了 ServletContext 和 ServletConfig 对象。</p>
<h2 id="DispatcherServlet初始化策略类"><a href="#DispatcherServlet初始化策略类" class="headerlink" title="DispatcherServlet初始化策略类"></a>DispatcherServlet初始化策略类</h2><p>DispatcherServlet.onRefresh 方法是 DispatcherServlet 的入口方法，DispatcherServlet.initStrategies 方法中初始化默认九个策略组件：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    initStrategies(context);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化DispatcherServlet默认的九个策略组件</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// 配置文件上传接口</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    <span class="comment">// 配置本地化解析</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    <span class="comment">// 配置主题解析</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 配置映射处理器</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 配置HandlerAdapter</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">// 配置处理器异常解析</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="comment">// 配置RequestToViewNameTranslator</span></span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 配置驶入解析器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    <span class="comment">// 配置FlashMap</span></span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>DispatcherServlet 启动时会进行配置需要的 Web 层 bean，如 HandlerMapping 、 HandlerAdapter 等，而且如果我们没有配置，还会给我们提供默认的配置。</p>
<h3 id="初始化MultipartResolver"><a href="#初始化MultipartResolver" class="headerlink" title="初始化MultipartResolver"></a>初始化MultipartResolver</h3><p>initMultipartResolver 方法初配置文件上传解析，由于并不是所有的请求都是上传文件请求，因此，默认的情况下， DispatcherServlet.properties 文件中没有提供 MultipartResolver 的实现类。</p>
<p>当请求为上传文件的请求时，必须手动注册MultipartResolver。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MULTIPART_RESOLVER_BEAN_NAME = <span class="string">"multipartResolver"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 从IoC容器中获取MultipartResolver组件，如果不存在则创建</span></span><br><span class="line">        <span class="keyword">this</span>.multipartResolver =</span><br><span class="line">            context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Using MultipartResolver ["</span> + <span class="keyword">this</span>.multipartResolver + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">        <span class="keyword">this</span>.multipartResolver = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Unable to locate MultipartResolver with name '"</span></span><br><span class="line">                         + MULTIPART_RESOLVER_BEAN_NAME +</span><br><span class="line">                         <span class="string">"': no multipart request handling provided"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化LocaleResolver"><a href="#初始化LocaleResolver" class="headerlink" title="初始化LocaleResolver"></a>初始化LocaleResolver</h3><p>先判断是否手动指定注册 LocaleResolver，如果手动指定 LocaleResolver，则从 IoC 容器中获取指定的 LocaleResolver，否则加载默认的 AcceptHeaderLocaleResolver。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALE_RESOLVER_BEAN_NAME = <span class="string">"localeResolver"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLocaleResolver</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 从IoC容器中获取LOcaleResolver</span></span><br><span class="line">        <span class="keyword">this</span>.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME,</span><br><span class="line">                                              LocaleResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Detected "</span> + <span class="keyword">this</span>.localeResolver);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Detected "</span> + <span class="keyword">this</span>.localeResolver.getClass().getSimpleName());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">        <span class="comment">// 如果IoC容器中LocalResolver对应BeanDefinition，则使用默认的策略类</span></span><br><span class="line">        <span class="keyword">this</span>.localeResolver = getDefaultStrategy(context, LocaleResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"No LocaleResolver '"</span> + LOCALE_RESOLVER_BEAN_NAME</span><br><span class="line">                         + <span class="string">"': using default ["</span></span><br><span class="line">                         + <span class="keyword">this</span>.localeResolver.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化ThemeResolver"><a href="#初始化ThemeResolver" class="headerlink" title="初始化ThemeResolver"></a>初始化ThemeResolver</h3><p>先判断是否手动指定注册 ThemeResolver，如果手动指定 ThemeResolver，则从 IoC 容器中获取指定的 LocaleResolver，否则加载默认的 FixedThemeResolver。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initThemeResolver</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 从IoC容器中获取ThemeResolver</span></span><br><span class="line">        <span class="keyword">this</span>.themeResolver = context.getBean(THEME_RESOLVER_BEAN_NAME,</span><br><span class="line">                                             ThemeResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Detected "</span> + <span class="keyword">this</span>.themeResolver);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Detected "</span> + <span class="keyword">this</span>.themeResolver.getClass().getSimpleName());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">        <span class="comment">// 当IoC容器没有ThemeResolver对应的BeanDefinition，则使用默认的</span></span><br><span class="line">        <span class="keyword">this</span>.themeResolver = getDefaultStrategy(context, ThemeResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"No ThemeResolver '"</span> + THEME_RESOLVER_BEAN_NAME</span><br><span class="line">                         + <span class="string">"': using default ["</span></span><br><span class="line">                         + <span class="keyword">this</span>.themeResolver.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化HandlerMapping"><a href="#初始化HandlerMapping" class="headerlink" title="初始化HandlerMapping"></a>初始化HandlerMapping</h3><p>先判断是否手动指定注册 HandlerMapping，如果手动指定 HandlerMapping，则从 IoC 容器中获取指定的 HandlerMapping，否则加载默认的两个：BeanNameUrlHandlerMapping、RequestMappingHandlerMapping。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HANDLER_MAPPING_BEAN_NAME = <span class="string">"handlerMapping"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// detectAllHandlerMappings默认为true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) {</span><br><span class="line">        <span class="comment">// 在ApplicationContext中查找所有HandlerMappings，包括祖先上下文。</span></span><br><span class="line">        Map<string, handlermapping> matchingBeans =</string,></span><br><span class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span><br><span class="line">                                       HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 如果容器中有HandlerMapping组件则将HandlerMapping组件添加到handlerMappings集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) {</span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList<handlermapping>(matchingBeans.values());</handlermapping></span><br><span class="line">            <span class="comment">// 对HandlerMapping进行排序</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 查找键为handlerMapping的HandlerMapping对象，包含祖先容器上下文</span></span><br><span class="line">            HandlerMapping hm = </span><br><span class="line">                context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有配置，取DispatcherServlet.properties中的默认配置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName()</span><br><span class="line">                         + <span class="string">"': using default"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化HandlerAdapter"><a href="#初始化HandlerAdapter" class="headerlink" title="初始化HandlerAdapter"></a>初始化HandlerAdapter</h3><p>Spring MVC 会默认注册三个 HandlerAdapter：</p>
<ul>
<li>HttpRequestHandlerAdapter</li>
<li>HttpRequestHandlerAdapter</li>
<li>RequestMappingHandlerAdapter</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerAdapters</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>.handlerAdapters = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果自动检测HandlerAdapter，默认是自动检测容器中的HandlerAdapter</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerAdapters) {</span><br><span class="line">		<span class="comment">// 在ApplicationContext中查找所有HandlerAdapter，包括祖先上下文</span></span><br><span class="line">		Map<string, handleradapter> matchingBeans = BeanFactoryUtils</string,></span><br><span class="line">			.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) {</span><br><span class="line">			<span class="keyword">this</span>.handlerAdapters = <span class="keyword">new</span> ArrayList<>(matchingBeans.values());</span><br><span class="line">			<span class="comment">// 排序</span></span><br><span class="line">			AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerAdapters);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 从IoC容器中获取指定beanName的HandlerAdapter</span></span><br><span class="line">			HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME,</span><br><span class="line">					HandlerAdapter.class);</span><br><span class="line">			<span class="keyword">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有注册HadnlerAdapter，则加载默认的HandlerAdapter</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">			logger.trace(<span class="string">"No HandlerAdapters declared for servlet '"</span></span><br><span class="line">					+ getServletName()</span><br><span class="line">					+ <span class="string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化HandlerExceptionResolver"><a href="#初始化HandlerExceptionResolver" class="headerlink" title="初始化HandlerExceptionResolver"></a>初始化HandlerExceptionResolver</h3><p>如果没有指定 HandlerExceptionResolver，Spring MVC 会加载默认的三个 HandlerExceptionResolver：</p>
<ul>
<li><p>ExceptionHandlerExceptionResolver</p>
</li>
<li><p>ResponseStatusExceptionResolver</p>
</li>
<li><p>DefaultHandlerExceptionResolver</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerExceptionResolvers</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>.handlerExceptionResolvers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从IoC容器中加载HandlerExceptionResolver    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerExceptionResolvers) {</span><br><span class="line">        <span class="comment">// 在ApplicationContext中查找所有HandlerExceptionResolver，包括祖先上下文</span></span><br><span class="line">		Map<string, handlerexceptionresolver> matchingBeans = BeanFactoryUtils</string,></span><br><span class="line">				.beansOfTypeIncludingAncestors(context,</span><br><span class="line">					HandlerExceptionResolver.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) {</span><br><span class="line">			<span class="keyword">this</span>.handlerExceptionResolvers = <span class="keyword">new</span> ArrayList<>(matchingBeans.values());</span><br><span class="line">			<span class="comment">// We keep HandlerExceptionResolvers in sorted order.</span></span><br><span class="line">			AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerExceptionResolvers);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			HandlerExceptionResolver her = context.getBean(</span><br><span class="line">				HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);</span><br><span class="line">			<span class="keyword">this</span>.handlerExceptionResolvers = Collections.singletonList(her);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有手动注册HandlerExceptionResolver，则加载默认三个HandlerExceptionResolver</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerExceptionResolvers == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">this</span>.handlerExceptionResolvers = getDefaultStrategies(</span><br><span class="line">			context, HandlerExceptionResolver.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">			logger.trace(<span class="string">"No HandlerExceptionResolvers declared in servlet '"</span></span><br><span class="line">					+ getServletName()</span><br><span class="line">					+ <span class="string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化RequestToViewNameTranslator"><a href="#初始化RequestToViewNameTranslator" class="headerlink" title="初始化RequestToViewNameTranslator"></a>初始化RequestToViewNameTranslator</h3><p>如果没有手动注册 RequestToViewNameTranslator，那么就会从DispatcherServlet.properties 文件中加载默认的 DefaultRequestToViewNameTranslator</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRequestToViewNameTranslator</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">this</span>.viewNameTranslator = context.getBean(</span><br><span class="line">			REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME,</span><br><span class="line">            RequestToViewNameTranslator.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Detected "</span></span><br><span class="line">				+ <span class="keyword">this</span>.viewNameTranslator.getClass().getSimpleName());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Detected "</span> + <span class="keyword">this</span>.viewNameTranslator);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">        <span class="comment">// 加载默认的RquestToViewNameTranslator</span></span><br><span class="line">        <span class="keyword">this</span>.viewNameTranslator = getDefaultStrategy(</span><br><span class="line">			context, RequestToViewNameTranslator.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"No RequestToViewNameTranslator '"</span></span><br><span class="line">					+ REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME</span><br><span class="line">					+ <span class="string">"': using default ["</span></span><br><span class="line">					+ <span class="keyword">this</span>.viewNameTranslator.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化ViewResolver"><a href="#初始化ViewResolver" class="headerlink" title="初始化ViewResolver"></a>初始化ViewResolver</h3><p>如果手动指定了 ViewResolver，则从 IoC 容器中获取指定的 ViewResolver，如果没有手动注册，则加载默认的 InternalResourceViewResolver</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViewResolvers</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="keyword">this</span>.viewResolvers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先从IoC容器查找是否手动注册ViewResolver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllViewResolvers) {</span><br><span class="line">		Map<string, viewresolver> matchingBeans = BeanFactoryUtils</string,></span><br><span class="line">			.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) {</span><br><span class="line">			<span class="keyword">this</span>.viewResolvers = <span class="keyword">new</span> ArrayList<>(matchingBeans.values());</span><br><span class="line">			<span class="comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">			AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.viewResolvers);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			ViewResolver vr = context.getBean(</span><br><span class="line">				VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line">			<span class="keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">			<span class="comment">// Ignore, we'll add a default ViewResolver later.</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有手动注册ViewResolver，则加载默认的InternalResourceViewResolver</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.viewResolvers == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">			logger.trace(<span class="string">"No ViewResolvers declared for servlet '"</span></span><br><span class="line">					+ getServletName()</span><br><span class="line">					+ <span class="string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初始化FlashMapManager"><a href="#初始化FlashMapManager" class="headerlink" title="初始化FlashMapManager"></a>初始化FlashMapManager</h3><p>FlashMapManager 用于解决 HTTP 重定向请求的时候，被存储到请求数据不会丢失，使得下一次GET请求可以访问到上一次请求中的一些有用的信息，Spring MVC 默认使用 SessionFlashMapManager。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFlashMapManager</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">this</span>.flashMapManager = context.getBean(</span><br><span class="line">			FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"Detected "</span></span><br><span class="line">				+ <span class="keyword">this</span>.flashMapManager.getClass().getSimpleName());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Detected "</span> + <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">        <span class="comment">// We need to use the default.</span></span><br><span class="line">        <span class="keyword">this</span>.flashMapManager = getDefaultStrategy(context, FlashMapManager.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"No FlashMapManager '"</span> + FLASH_MAP_MANAGER_BEAN_NAME</span><br><span class="line">						+  <span class="string">"': using default ["</span></span><br><span class="line">						+ <span class="keyword">this</span>.flashMapManager.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><p>整个 DispatcherServlet 初始化的过程主要做了如下两件事情：</p>
<p>1、Spring MVC 中的 Servlet 一共有三个层次，分别是 HttpServletBean、FrameworkServlet、DispatcherServlet；</p>
<p>2、HttpServletBean 继承 HttpServlet，将 Servlet 中配置的参数设置到相应的属性中；</p>
<p>3、FrameworkServlet 初始化 WebApplicationContext，也就是初始化 Spring MVC 使用的 Web 上下文，并且可能指定父容器为（ContextLoaderListener 加载的根上下文）；</p>
<p>2、DispatcherServlet 根据 DispatcherServlet.properties 属性文件初始化默认的九个策略组件，如 MultipartResolver、LocaleResolver、ThemeResolver、HandlerMapping、HandlerAdapter、HandlerExceptionResolver、RequestToViewNameTranslator、ViewResolver、FlashMapManager（用于重定向时传递属性）。</p>
<p>DispatcherServlet 整个初始化流程为：</p>
<p><img src="https://ws1.sinaimg.cn/large/70dc5b5cgy1g5mkycs1akj20um0hzjs3.jpg" alt></p>
<p>Servlet.init(ServletConfig)  –> GenericServlet.init –> HttpServlet.init()  –> HttpServletBean.init() –> FrameworkSerlvlet.initServletBean() –> FrameworkSerlvlet.initWebApplicationContext() –> DispatcherSerlvlet.onRefresh()  –> FrameworkSerlvlet.initFrameworkServlet() </p>
<p>从流程图中可以，DispatcherServlet 的初始化时通过模板方法来实现，GenericServlet 提供 init 模板方法，HttpServletBean 中重写 init 方法，在 HttpServletBean 中定义 initServletBean 模板方法，FrameworkServlet 中 定义 onRefresh 模板方法，DispatcherServlet 重写 onRefresh 方法，在 onRefresh 方法中调用 initStrategies 方法加载默认的策略类。</p>
<h1 id="DispactherServlet处理请求"><a href="#DispactherServlet处理请求" class="headerlink" title="DispactherServlet处理请求"></a>DispactherServlet处理请求</h1><p><img src="https://ws1.sinaimg.cn/large/70dc5b5cgy1g4ybsyz3scj20pp0gbaae.jpg" alt></p>
<p>在前面分析到 DispactherServlet 的初始化工作时一个三层结构，涉及到 HttpServletBean、FrameworkServlet、DispatcherServlet；</p>
<p>Servlet 的处理请求的入口方法是 Servlet 的 service(ServletRequest request, ServletResponse response) 方法，在 HttpServlet 中将 ServletRequest、ServletResponse 对象转换为 HttpServletRequest 、HttpServletResponse 对象，从而根据 HTTP 的请求类型将不同请求的路由到对应的 doGet、doPost、doHead、doPut 等模板方法，子类只需要重写模板方法即可。</p>
<p>在 HttpServletBean 的源码中并没有发现它重写 service 方法，也就说 HttpServletBean 并不处理请求，直接使用父类的  service(HttpServletRequest request, HttpServletResponse response) 方法，HttpServletBean 的主要是初始化 Servlet 的工作，而没有涉及到请求的处理工作。</p>
<h2 id="FrameworkServlet-service-方法"><a href="#FrameworkServlet-service-方法" class="headerlink" title="FrameworkServlet.service 方法"></a>FrameworkServlet.service 方法</h2><p>FrameworkServlet 重写了 HttpServlet 的 service 方法：增加了对 PATCH 请求类型的处理（PATCH 请求用于资源的部分更新，而PUT 用于更新资源完整的内容），其他的都是直接交给父类 HttpServlet 处理，而在父类 HttpServlet 的 service 方法中会调用 FrameworkServlet 重写 doXxx 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">    <span class="comment">// 如果是PATCH方法（资源的部分更新）</span></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) {</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 直接交给父类处理，父类会调用FrameworkServlet重写的doXxx方法</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">super</span>.service(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>FrameworkServlet 除了没有重写 doHead 方法外，重写了 doGet、doPost、doPut、doDelete、doOptions、doTrace 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    processRequest(request, response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    processRequest(request, response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    processRequest(request, response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    processRequest(request, response);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>doGet、doPost、doPut、doDelete 方法都是通过 processRequest(HttpServletRequest request, HttpServletResponse response) 同一处理；而 doOptions、doTrace 方法通过设置 dispatchOptionsRequest 和 dispatchTraceRequest 参数来决定自己处理还是交给父类处理，默认是交给父类处理。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOptions</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) {</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">        <span class="keyword">if</span> (response.containsHeader(<span class="string">"Allow"</span>)) {</span><br><span class="line">            <span class="comment">// Proper OPTIONS response coming from a handler - we're done.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use response wrapper in order to always add PATCH to the allowed methods</span></span><br><span class="line">    <span class="keyword">super</span>.doOptions(request, <span class="keyword">new</span> HttpServletResponseWrapper(response) {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String name, String value)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"Allow"</span>.equals(name)) {</span><br><span class="line">                value = (StringUtils.hasLength(value) ? value + <span class="string">", "</span> : <span class="string">""</span>)</span><br><span class="line">                    + HttpMethod.PATCH.name();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">super</span>.setHeader(name, value);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTrace</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dispatchTraceRequest) {</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"message/http"</span>.equals(response.getContentType())) {</span><br><span class="line">            <span class="comment">// Proper TRACE response coming from a handler - we're done.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">super</span>.doTrace(request, response);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="FrameworkServlet-processRequest"><a href="#FrameworkServlet-processRequest" class="headerlink" title="FrameworkServlet.processRequest"></a>FrameworkServlet.processRequest</h2><p>在前面分析到 FrameworkServlet 的doGet、doPost、doPut、doDelete 方法都是通过 processRequest  同一处理；<strong>这里会发现 HttpServlet 将不同类型的请求路由到不同的方法里进行处理，而 FrameworkServlet 却将所有的请求都合并到 processRequest 方法中进行处理，</strong>这里的一个重要原因就是：<font color="red">Spring MVC 将不同的请求使用不同的 Handler 进行处理。</font></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">           HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取LocaleContextHolder中保存的LocaleContext</span></span><br><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">    <span class="comment">// 创建当前请求的LocaleContext</span></span><br><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取RequestContextHolder中保存的RequestAttributes</span></span><br><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="comment">// 创建当前请求的ServletRequestAttributes</span></span><br><span class="line">    ServletRequestAttributes requestAttributes =</span><br><span class="line">        buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 处理异步请求的异步管理器</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    <span class="comment">// 注册拦截当前请求的拦截器CallableProcessingInterceptor</span></span><br><span class="line">    asyncManager.registerCallableInterceptor(</span><br><span class="line">        FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将当前请求的LocaleContext和ServletRequestAttributes</span></span><br><span class="line">    <span class="comment">// 分别设置到LocalContextHolder和RequestContextHolder中</span></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 实例处理请求的入口方法：这是一个模板方法，由子类实现</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) {</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 恢复原来的LocaleContext和ServletRequestAttributes到LocalContextHolder</span></span><br><span class="line">        <span class="comment">// 和RequestContextHolder中</span></span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 标记当前请求处理完成</span></span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        }</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        <span class="comment">// 发布ServletRequestHandledEvent事件</span></span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>分析源码可以看出，processRequest方法的流程比较清晰，主要做如下几件事：</p>
<p>1、获取LocaleContextHolder 和 RequestContextHolder中保存的 LocaleContext 和 RequestAttributes对象，并暂存它们，然后根据它们创建当前请求的 LocaleContext 和 ServletRquestAttributes 对象；</p>
<p>2、将当前请求的 LocaleContext 和 ServletRequestAttributes 分别设置到 LocalContextHolder 和 RequestContextHolder 中；</p>
<p>3、调用子类重写的 doService(request, response) 方法处理请求；</p>
<p>4、处理完请求后恢复原来的 LocaleContext 和 ServletRequestAttributes 对象，即将它们保存到 LocalContextHolder 和 RequestContextHolder 中，以便下次请求到来时再次获取；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetContextHolders</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">          LocaleContext prevLocaleContext, RequestAttributes previousAttributes)</span> </span>{</span><br><span class="line"></span><br><span class="line">    LocaleContextHolder.setLocaleContext(</span><br><span class="line">        prevLocaleContext, <span class="keyword">this</span>.threadContextInheritable);</span><br><span class="line">    RequestContextHolder.setRequestAttributes(</span><br><span class="line">        previousAttributes, <span class="keyword">this</span>.threadContextInheritable);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5、标记当前请求已经处理完成；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestCompleted</span><span class="params">()</span> </span>{</span><br><span class="line">    executeRequestDestructionCallbacks();</span><br><span class="line">    updateAccessedSessionAttributes();</span><br><span class="line">    <span class="keyword">this</span>.requestActive = <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>6、无论请求是否执行成功都会发布 ServletRequestHandledEvent 事件</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishRequestHandledEvent</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, <span class="keyword">long</span> startTime, Throwable failureCause)</span> </span>{</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// publishEvents默认为true</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.publishEvents && <span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">long</span> processingTime = System.currentTimeMillis() - startTime;</span><br><span class="line">		<span class="keyword">this</span>.webApplicationContext.publishEvent(</span><br><span class="line">				<span class="keyword">new</span> ServletRequestHandledEvent(<span class="keyword">this</span>,</span><br><span class="line">						request.getRequestURI(), request.getRemoteAddr(),</span><br><span class="line">						request.getMethod(), getServletConfig().getServletName(),</span><br><span class="line">						WebUtils.getSessionId(request), getUsernameForRequest(request),</span><br><span class="line">						processingTime, failureCause, response.getStatus()));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="LocalContext"><a href="#LocalContext" class="headerlink" title="LocalContext"></a>LocalContext</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocaleContext</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Locale</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Locale <span class="title">getLocale</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LocalContext 的作用作用是获取 LocalConext，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleContextHolder</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal<localecontext> localeContextHolder =</localecontext></span><br><span class="line">        <span class="keyword">new</span> NamedThreadLocal<>(<span class="string">"LocaleContext"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal<localecontext> inheritableLocaleContextHolder =</localecontext></span><br><span class="line">        <span class="keyword">new</span> NamedInheritableThreadLocal<>(<span class="string">"LocaleContext"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Locale defaultLocale;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeZone defaultTimeZone;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LocaleContextHolder</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .........</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LocalContextHolder 持有 LocalContext 的引用，还可以获取 Locale 和 TimeZone 。它使用 ThreadLocal 保证每个线程都有一份 LocaleContext 的引用，当我们想要在其他地方使用的时候就可以直接通过 LocaleContextHolder.getLocalContext() 方法获取。</p>
<p>同理，RequestContextHolder 也是一样的，可以在任何地方通过 RequestContextHolder.getRequestAttributes() 方法获取 RequestAttributes 对象。</p>
<h3 id="RequestAttributes"><a href="#RequestAttributes" class="headerlink" title="RequestAttributes"></a>RequestAttributes</h3><p>RequestAttributes 用于管理 HttpServletRqeuest 和 HttpSession 的属性，可以通过 RequestAttributes 获取 HttpServletRequest、HttpServletResponse 、HttpSession 对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestAttributes</span> </span>{</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// reqeust作用域</span></span><br><span class="line">	<span class="keyword">int</span> SCOPE_REQUEST = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// session作用域</span></span><br><span class="line">	<span class="keyword">int</span> SCOPE_SESSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	String REFERENCE_REQUEST = <span class="string">"request"</span>;</span><br><span class="line"></span><br><span class="line">	String REFERENCE_SESSION = <span class="string">"session"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Object <span class="title">getAttribute</span><span class="params">(String name, <span class="keyword">int</span> scope)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value, <span class="keyword">int</span> scope)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name, <span class="keyword">int</span> scope)</span></span>;</span><br><span class="line"></span><br><span class="line">	String[] getAttributeNames(<span class="keyword">int</span> scope);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback, <span class="keyword">int</span> scope)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Object <span class="title">resolveReference</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getSessionId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Object <span class="title">getSessionMutex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>RequestAttributes 是用于访问与请求关联的属性对象接口，主要用于操作与请求关联的属性，支持访问 request 作用域和 session作用域的属性。</p>
<p>ServletRequestAttributes 是 RequestAttributes 的一个实现类，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value, <span class="keyword">int</span> scope)</span> </span>{</span><br><span class="line">    <span class="comment">// 如请求是reqeust作用域，将属性设置到HttpServletRequest中</span></span><br><span class="line">    <span class="keyword">if</span> (scope == SCOPE_REQUEST) {</span><br><span class="line">        <span class="comment">// 判断当前请求是否还没有处理，如果已经处理完成则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isRequestActive()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Cannot set request attribute - request is not active anymore!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.request.setAttribute(name, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 请求为session作用域，将属性设置到HttpSession中</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        HttpSession session = obtainSession();</span><br><span class="line">        <span class="keyword">this</span>.sessionAttributesToUpdate.remove(name);</span><br><span class="line">        session.setAttribute(name, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>isRequestActive 方法判断当前请求是否没有处于激活状态，激活状态表示请求还没有处理</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> requestActive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRequestActive</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.requestActive;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当请求处理完成后会将 requestActive 设置为false</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestCompleted</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 如果执行回调</span></span><br><span class="line">    executeRequestDestructionCallbacks();</span><br><span class="line">    updateAccessedSessionAttributes();</span><br><span class="line">    <span class="keyword">this</span>.requestActive = <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="DispatcherServlet-doService方法"><a href="#DispatcherServlet-doService方法" class="headerlink" title="DispatcherServlet.doService方法"></a>DispatcherServlet.doService方法</h2><p>doService(HttpServletRequest request, HttpServletResponse response) 方法是 FrameworkServlet 提供给子类处理请求的模板方法，doService 方法是 DispatcherServlet 中的入口方法，doServcie 方法没有执行具体的处理工作，而是交给 doDispatcher 方法完成。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>{</span><br><span class="line">	logRequest(request);</span><br><span class="line"></span><br><span class="line">	Map<string, object> attributesSnapshot = <span class="keyword">null</span>;</string,></span><br><span class="line">    <span class="comment">// 当include请求时对request的属性做备份</span></span><br><span class="line">	<span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) {</span><br><span class="line">		attributesSnapshot = <span class="keyword">new</span> HashMap<>();</span><br><span class="line">		Enumeration<?> attrNames = request.getAttributeNames();</span><br><span class="line">		<span class="keyword">while</span> (attrNames.hasMoreElements()) {</span><br><span class="line">			String attrName = (String) attrNames.nextElement();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude</span><br><span class="line">                	|| attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {</span><br><span class="line">				attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置request的属性，如Web上下文、本地化解析器、主题解析器、主题源</span></span><br><span class="line">	request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">	request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">	request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">	request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向传递参数</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) {</span><br><span class="line">		FlashMap inputFlashMap = </span><br><span class="line">            <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">		<span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) {</span><br><span class="line">			request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE,</span><br><span class="line">                                 Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">		}</span><br><span class="line">		request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">		request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 调用doDispatch方法处理请求</span></span><br><span class="line">		doDispatch(request, response);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">finally</span> {</span><br><span class="line">		<span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {</span><br><span class="line">            <span class="comment">// 如果是include请求，那么清除request备份的属性</span></span><br><span class="line">			<span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) {</span><br><span class="line">				restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="DispatcherServlet-doDispatch方法"><a href="#DispatcherServlet-doDispatch方法" class="headerlink" title="DispatcherServlet.doDispatch方法"></a>DispatcherServlet.doDispatch方法</h2><p>DispactherServlet 处理请求返回响应流程在 doDispatcher 方法，<font color="red">doDispatch 方法的主要任务为：</font></p>
<ul>
<li>根据 request 找到对应的 Handler（使用@Controller注解标注的类）</li>
<li>将 handler 包装为 HandlerAdapter</li>
<li>用 HandlerAdapter 处理 Handler</li>
<li>调用 processDispatcherResult 方法处理之后的结果</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 上传请求标识</span></span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 记录内层异常</span></span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 1.检查请求是否是multipart（文件上传），如果是则使用MultipartResolver解析</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.根据request找到HandlerExecutionChain，</span></span><br><span class="line"><span class="comment">             * 请求到处理器/页面控制器的映射，通过HandlerMapping进行映射</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) {</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.将andler包装为HandlerAdapter（处理器适配）</span></span><br><span class="line">            <span class="comment">// 将处理器包装成相应的适配器，从而支持多种类型的处理器</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.处理GET、HEAD请求的Last-Modified</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) {</span><br><span class="line">                <span class="keyword">long</span> lastModified =</span><br><span class="line">                    ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request,response)</span><br><span class="line">						.checkNotModified(lastModified) && isGet) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 5.执行处理器相关的拦截器的预处理preHandle</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 6.由适配器执行处理器，调用处理器相应的功能处理方法</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">			<span class="comment">// 如果需要异步处理直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">			<span class="comment">// 7.如果view为空，根据request设置默认view</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 8.执行处理器相关的拦截器的后处理postHandle</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 内层异常处理</span></span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) {</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(</span><br><span class="line">                <span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9.处理返回结果：包括异常处理、渲染视图、发出完成通知触发Interceptor的afterCompleion</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler,</span><br><span class="line">                              mv, dispatchException);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 外层异常处理：processDispatchResult 方法抛出的异常</span></span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) {</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">               <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 判断是否执行异步请求</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) {</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(</span><br><span class="line">                    processedRequest, response);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果是上传文件请求则删除上传请求的数据</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) {</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> doDispatcher 方法主要作用是 <font color="red">处理请求和渲染视图</font>，主要流程流程为：</p>
<p>1、检查是否是上传请求，如果是上传请求，将 request 转换为 MultiHttpServletRequest，并将上传请求标识 multipartRequestParsed 设置为 true；</p>
<p>2、根据 request 找到 HandlerMapping处理请求，返回一个处理器链：HandlerExecutionChain；</p>
<p>3、将handler包装为HandlerAdapter</p>
<p>4、处理 GET/POST 方法的 Last-Modification；</p>
<p>5、执行 HandlerExecutionChain#preHandler方法</p>
<p>6、HandlerAdapter调用处理器相应的功能处理方法</p>
<p>7、判断是否需要异步处理，如果是异步请求，则直接返回，不再执行后续过程；</p>
<p>8、如果 HanlderAdapter 处理请求完后返回为空，则设置默认的视图名；</p>
<p>9、调用 processDispatchResult 方法处理前面步骤返回的结果，包含异常处理、视图渲染、触发 Interceptor 的afterCompleion 方法发出请求处理完成通知。</p>
<h3 id="检查上传请求"><a href="#检查上传请求" class="headerlink" title="检查上传请求"></a>检查上传请求</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MultipartResolver multipartResolver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HttpServletRequest <span class="title">checkMultipart</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> MultipartException </span>{</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.multipartResolver != <span class="keyword">null</span> && <span class="keyword">this</span>.multipartResolver.isMultipart(request)) {</span><br><span class="line">		<span class="keyword">if</span> (WebUtils.getNativeRequest(request,</span><br><span class="line">                                      	MultipartHttpServletRequest.class) != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">if</span> (request.getDispatcherType().equals(DispatcherType.REQUEST)) {</span><br><span class="line">				logger.trace(<span class="string">"Request already resolved to"</span></span><br><span class="line">						+<span class="string">" MultipartHttpServletRequest, e.g. by MultipartFilter"</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (hasMultipartException(request)) {</span><br><span class="line">			logger.debug(<span class="string">"Multipart resolution previously failed for current"</span></span><br><span class="line">                         + <span class="string">" request - skipping re-resolution for"</span></span><br><span class="line">                         + <span class="string">" undisturbed error rendering"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.multipartResolver.resolveMultipart(request);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">catch</span> (MultipartException ex) {</span><br><span class="line">				<span class="keyword">if</span> (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != <span class="keyword">null</span>) {</span><br><span class="line">					logger.debug(<span class="string">"Multipart resolution failed for error dispatch"</span>, ex);</span><br><span class="line">					<span class="comment">// Keep processing error dispatch with regular request handle below</span></span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">else</span> {</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// If not returned before: return original request.</span></span><br><span class="line">	<span class="keyword">return</span> request;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>MultipartResolver 是处理上传请求的策略类，在 Spring MVC 配置的默认策略类中并不包含 MultipartSolver，</p>
<h3 id="根据request找到HandlerMapping"><a href="#根据request找到HandlerMapping" class="headerlink" title="根据request找到HandlerMapping"></a>根据request找到HandlerMapping</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List<handlermapping> handlerMappings;</handlermapping></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 如果handlerMappings不为空，则遍历所有HandlerMapping，找到合适的HandlerMapping处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) {</span><br><span class="line">            HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Spring MVC 默认会配置 BeanNameUrlHandlerMapping、RequestMappingHandlerMapping 两个 HandlerMapping，HandlerMapping 执行后返回一个 HandlerExecutionChain 对象；HandlerExecutionChain 包含多个拦截器 Interceptor 和一个处理器 handler；执行时先执行 Interceptor 的 preHandler方法，然后执行 handler 的处理方法；返回时先执行 Interceptor 的 postHandler 方法。</p>
<h3 id="将handler包装为HandlerAdapter"><a href="#将handler包装为HandlerAdapter" class="headerlink" title="将handler包装为HandlerAdapter"></a>将handler包装为HandlerAdapter</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List<handleradapter> handlerAdapters;</handleradapter></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历所有HandlerAdapter，判断谁支持处理handler，则返回该HandlerAdapter</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) {</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) {</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler + <span class="string">"]: The"</span></span><br><span class="line">                    + <span class="string">" DispatcherServlet configuration needs to include"</span></span><br><span class="line">                    + <span class="string">" a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Spring MVC 默认会配置 HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、RequestMappingHandlerAdapter 三个 HadnlerAdapter；将 hanlder 包装为 HandlerAdapter。</p>
<h3 id="处理-GET-POST-方法的-Last-Modification"><a href="#处理-GET-POST-方法的-Last-Modification" class="headerlink" title="处理 GET/POST 方法的 Last-Modification"></a>处理 GET/POST 方法的 Last-Modification</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理GET、HEAD请求的Last-Modified</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) {</span><br><span class="line">    <span class="keyword">long</span> lastModified =</span><br><span class="line">        ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request,response)</span><br><span class="line">        .checkNotModified(lastModified) && isGet) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当浏览器第一访问服务器的请求资源时，服务器会在返回响应的响应头中增加一个 Last-Modification 属性，表示该资源最后什么时候修改的；浏览器再次访问该资源时，会发送之前接收到 的 Last-Modification 属性给服务器，服务器收到带 Last-Modification 属性的请求后，与资源实际修改时间进行对比，如果资源过期则返回新的资源，同时返回新的 Last-Modification 属性；如果资源没有过期，直接返回 <strong>304</strong> 状态码，表示资源没有过期，浏览器收到 <strong>304</strong> 状态码后直接使用缓存的结果。</p>
<h3 id="执行-HandlerExecutionChain-preHandler方法"><a href="#执行-HandlerExecutionChain-preHandler方法" class="headerlink" title="执行 HandlerExecutionChain#preHandler方法"></a>执行 HandlerExecutionChain#preHandler方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>HandlerExecutionChain#applyPreHandler 方法为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历所有的拦截器HandlerInterceptor，执行preHandler方法，</span></span><br><span class="line"><span class="comment">         * 每个拦截器都可以决定中止执行链，通常发送HTTP错误或编写自定义响应</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < interceptors.length; i++) {</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果终止拦截器拦截或者执行完最后一个handler本身(我们书写的Controller),</span></span><br><span class="line"><span class="comment">             * 则触发所有拦截器triggerAfterCompletion</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) {</span><br><span class="line">                triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>HandlerExecutionChain#triggerAfterCompletion 方法为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">		Exception ex)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">	HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历所有的拦截器HandlerInterceptor，执行afterCompletion方法,表示该拦截器处理完请求</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i >= <span class="number">0</span>; i--) {</span><br><span class="line">			HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex2) {</span><br><span class="line">				logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="HandlerAdapter调用handler的功能处理方法"><a href="#HandlerAdapter调用handler的功能处理方法" class="headerlink" title="HandlerAdapter调用handler的功能处理方法"></a>HandlerAdapter调用handler的功能处理方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></tbody></table></figure>

<p><font color="red">拦截器执行 preHandler 方法后，就是调用 HandlerAdapter.handle 方法处理请求，返回 ModelAndView，这就是我们书写的 Controller 在这里执行。</font></p>
<p>HttpRequestHandlerAdapter 处理请求：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">		((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) {</span><br><span class="line">			<span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SimpleControllerHandlerAdapter 处理请求：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) {</span><br><span class="line">			<span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SimpleServletHandlerAdapter 处理请求：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleServletHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Servlet);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">		((Servlet) handler).service(request, response);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后还有 AbstractHandlerMethodAdapter 的子类，它有一个实现类 RequestMappingHandlerAdapter，在 AbstractHandlerMethodAdapter 内部，把请求的处理交给子类重写的 handleInternal 方法来实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">		Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果需要异步处理直接返回</span></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这一步就是判断请求是否需要异步执行，如果需要异步执行，则返回。如果不需要异步处理则进行下一步处理。</p>
<p>其中 WebAsyncManager#isConcurrentHandlingStarted 方法为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AsyncWebRequest asyncWebRequest;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConcurrentHandlingStarted</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span> && <span class="keyword">this</span>.asyncWebRequest.isAsyncStarted());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="设置默认视图名"><a href="#设置默认视图名" class="headerlink" title="设置默认视图名"></a>设置默认视图名</h3><p>如果 HanlderAdapter 处理请求完后返回为空，也就是 view 为空，则调用 applyDefaultViewName 方法设置默认视图。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyDefaultViewName</span><span class="params">(HttpServletRequest request, ModelAndView mv)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> && !mv.hasView()) {</span><br><span class="line">        String defaultViewName = getDefaultViewName(request);</span><br><span class="line">        <span class="keyword">if</span> (defaultViewName != <span class="keyword">null</span>) {</span><br><span class="line">            mv.setViewName(defaultViewName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="执行-HandlerExecutionChain-postHandler方法"><a href="#执行-HandlerExecutionChain-postHandler方法" class="headerlink" title="执行 HandlerExecutionChain#postHandler方法"></a>执行 HandlerExecutionChain#postHandler方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历所有HandlerInterceptor，调用postHandle方法处理请求</span></span><br><span class="line"><span class="comment">     * 遍历HandlerInterceptor的顺序与preHandle方法的顺序相反</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="执行-processDispatchResult-方法"><a href="#执行-processDispatchResult-方法" class="headerlink" title="执行 processDispatchResult 方法"></a>执行 processDispatchResult 方法</h3><p>processDispatchResult 方法处理返回结果：包括异常处理、渲染视图、触发 HandlerInterceptor 拦截器的   afterCompleion 方法发出请求处理完成通知。</p>
<p>doDispatch 有两层异常结构：内层捕获在对请求进行处理过程中抛出的异常；外层是在处理渲染视图时抛出的异常；也就是以 processDispatchResult 方法为分界线，内层异常会记录到 dispatchException 变量中，外层异常是指定 processDispatchResult 方法抛出的异常；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">               HttpServletResponse response, HandlerExecutionChain mappedHandler, </span></span></span><br><span class="line"><span class="function"><span class="params">               ModelAndView mv, Exception exception)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果内层异常不为空，也就是处理请求过程中抛出异常，则处理异常，将异常信息设置到视图中</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) {</span><br><span class="line">            logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染视图</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> && !mv.wasCleared()) {</span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) {</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">            logger.trace(<span class="string">"No view rendering, null ModelAndView returned."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是异步处理则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果handlerExecutionChain不为空，则触发HandlerInterceptor#afterCompletion方法</span></span><br><span class="line"><span class="comment">     * 发出请求处理完成通知</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) {</span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="渲染视图"><a href="#渲染视图" class="headerlink" title="渲染视图"></a>渲染视图</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">	<span class="comment">// 获取response对应Locale</span></span><br><span class="line">	Locale locale = (<span class="keyword">this</span>.localeResolver != <span class="keyword">null</span> </span><br><span class="line">		? <span class="keyword">this</span>.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">	<span class="comment">// 设置reponse的Locale</span></span><br><span class="line">    response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">	View view;</span><br><span class="line">    <span class="comment">// 获取视图名</span></span><br><span class="line">	String viewName = mv.getViewName();</span><br><span class="line">    <span class="comment">// 如果视图名不为空，根据视图名解析视图</span></span><br><span class="line">	<span class="keyword">if</span> (viewName != <span class="keyword">null</span>) {</span><br><span class="line">		view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">		<span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Could not resolve view with name '"</span></span><br><span class="line">					+ mv.getViewName() + <span class="string">"' in servlet with name '"</span></span><br><span class="line">					+ getServletName() + <span class="string">"'"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">// 如果视图名为空，则设置</span></span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">// 获取视图</span></span><br><span class="line">		view = mv.getView();</span><br><span class="line">		<span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a"</span></span><br><span class="line">						+ <span class="string">" view name nor a View object in servlet with name '"</span></span><br><span class="line">						+ getServletName() + <span class="string">"'"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">		logger.trace(<span class="string">"Rendering view ["</span> + view + <span class="string">"] "</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 设置response的响应码		</span></span><br><span class="line">		<span class="keyword">if</span> (mv.getStatus() != <span class="keyword">null</span>) {</span><br><span class="line">			response.setStatus(mv.getStatus().value());</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 根据模型数据渲染图</span></span><br><span class="line">		view.render(mv.getModelInternal(), request, response);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">			logger.debug(<span class="string">"Error rendering view ["</span> + view + <span class="string">"]"</span>, ex);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="触发请求处理完成通知"><a href="#触发请求处理完成通知" class="headerlink" title="触发请求处理完成通知"></a>触发请求处理完成通知</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, 			Exception ex)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历所有HandlerInterceptor，执行每个拦截器的afterCompletion方法</span></span><br><span class="line"><span class="comment">     * 从后向前遍历每个HandlerInterceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i >= <span class="number">0</span>; i--) {</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) {</span><br><span class="line">                logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是：触发拦截器 afterCompletion 方法的顺序与执行拦截器preHandle方法的顺序相反；</p>
<h2 id="处理请求总体流程"><a href="#处理请求总体流程" class="headerlink" title="处理请求总体流程"></a>处理请求总体流程</h2><p>1、用户发送请求 –> DispatcherServlet：前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>
<p>2、DispatcherServlet –> HandlerMapping（默认为 BeanNameUrlHandlerMapping）：HandlerMapping 把请求映射成 HandlerExecutionChain 对象（包含一个 Hadnler 处理器对象、多个 HandlerInterceptor 拦截器对象），通过策略模式很容易添加新的映射策略；</p>
<p>3、DispatcherServlet  –> HandlerAdapter（默认为 SimpleControllerHandlerAdapter）：HandlerAdapter 把处理器包装成适配器，从而支持多种类型的处理器，这里是使用适配器模式来支持多种类型的处理器；</p>
<p>4、HandlerAdapter –> 调用处理器（Controller 接口的实现类）功能处理方法（ ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) ）：HandlerAdapter 将会根据适配的结果调用真正的处理器功能处理方法，完成功能处理，并返回一个 ModelAndView 对象；ModelAndView 对象包含模型数据和逻辑视图名；</p>
<p>5、ModelAndView 逻辑视图名  –> ViewResolver（默认为 InternalResourceViewResolver）：ViewResolver 把逻辑视图名解析为具体的视图 View，也是通过策略模式实现，可以方便更换视图技术；</p>
<p>6、View （默认为 JstlView）–> 渲染：View 根据传递进来的 Model 模型数据进行渲染，Model 其实就是一个 Map 的数据结构，因此容易支持其他视图技术；</p>
<p>7、返回控制权给 DispatcherServlet，DispatcherServlet 返回响应给用户，结束请求-响应模型。 </p>
<p>从上面的流程可以看出，SpringMVC 处理请求的核心工作为：</p>
<p>1、DispatcherServlet 在 web.xml 中部署描述，从而拦截请求到 SpringMVC；</p>
<p>2、HandlerMapping 的配置，从而将请求映射到处理器；</p>
<p>3、HandlerAdapter的配置，从而支持多种类型处理器；</p>
<p>4、ViewResolver配置，从而逻辑视图名解析具体的视图；</p>
<p>5、处理器配置：进行功能处理。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h2><p>在 Web 容器启动时将调用 init 方法，将 DispatcherServlet 初始化参数（init-param）使用 BeanWrapper 设置到 DispatcherServlet 组件上，在初始化时将 DispatcherServlet  中的 <servlet> 标签的 <init-param> 子标签当做一个 bean；然后调用 HttpServletBean 的模板方法 initServletBean 初始化 Servlet；</init-param></servlet></p>
<h2 id="FrameworkServlet："><a href="#FrameworkServlet：" class="headerlink" title="FrameworkServlet："></a>FrameworkServlet：</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过重写父类 HttpServletBean 的 initServletBean 方法在完成 Servlet 的初始化，在 initServletBean 方法中主要做了两件事：</p>
<p>（1）创建由 DispatcherServlet 加载的  WebApplicationContext，并设置它的父容器：由 ContextLoaderListener 加载的根容器，以及完成容器的其他初始化，同时提供 onRefresh 模板方法来完成容器的刷新工作；</p>
<p>（2）定义 initFrameworkServlet 模板方法，默认为空，由子类重写实现特定的初始化需求；</p>
<h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>1、在 service 方法中增加对 HTTP PATCH 方法的支持；如果为 PATCH 请求则将请求交给 processRequest 方法直接处理，否则为其他类型的请求，则把请求交给父类 HttpServlet#service 方法处理；而 HttpServlet#service 方法会根据请求类型把请求的处理交给 FrameworkServlet#doXxx 方法，</p>
<p>2、FrameworkServlet 在 doXxx 方法大部分是将请求的处理统一交给 processRequest 方法处理，也就是说将不同类型的请求处理都合并到 processRequest 方法中，在 processRequest 方法主要做了如下三件事：</p>
<p>（1）将当前请求的 LocaleContext、ServletRequestAttributes 在处理请求前设置到 LocaleConetxtHolder、RequestContextHolder 中，在处理完后恢复；</p>
<p>（2）调用模板方法 doService 方法处理请求，doService 是在 DispatcherServlet 中实现；</p>
<p>（3）请求处理完成后发布 ServletRequestHandledEvent 事件；</p>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>DispatcherServlet#doService 方法完成请求的具体处理工作，</p>
<p>（1）首先对请求设置一些属性，比如当请求为 include 请求时，对当前 request 的属性进行备份；然后将当前的 web上下文、本地化解析器、主题解析器、主题源设置为 request 的属性保存下来，设置 FlashMap 解决重定向时数据传输问题； </p>
<p>（2）把请求交给 doDispatcher 方法处理；</p>
<p>doDispatcher 方法时完成请求处理的具体方法，这其中涉及都如下九个步骤：</p>
<p>1、检查是否是上传请求，如果是上传请求，将 request 转换为 MultiHttpServletRequest，并将上传请求标识 multipartRequestParsed 设置为 true；</p>
<p>2、根据 request 找到 HandlerMapping处理请求，返回一个处理器链：HandlerExecutionChain；</p>
<p>3、将handler包装为HandlerAdapter</p>
<p>4、处理 GET/POST 方法的 Last-Modification；</p>
<p>5、执行 HandlerExecutionChain#preHandler方法</p>
<p>6、HandlerAdapter调用处理器相应的功能处理方法</p>
<p>7、判断是否需要异步处理，如果是异步请求，则直接返回，不再执行后续过程；</p>
<p>8、如果 HanlderAdapter 处理请求完后返回为空，则设置默认的视图名；</p>
<p>9、调用 processDispatchResult 方法处理前面步骤返回的结果，包含异常处理、视图渲染、触发 Interceptor 的afterCompleion 方法发出请求处理完成通知。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SpringMVC/" rel="tag"># SpringMVC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/20/Java序列化/" rel="next" title="Java序列化">
                <i class="fa fa-chevron-left"></i> Java序列化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zuoshangan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#DispatcherServlet初始化和处理请求"><span class="nav-number">1.</span> <span class="nav-text">DispatcherServlet初始化和处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherServlet中使用的特殊Bean"><span class="nav-number">1.1.</span> <span class="nav-text">DispatcherServlet中使用的特殊Bean</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DispatcherServlet-初始化"><span class="nav-number">2.</span> <span class="nav-text">DispatcherServlet 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-xml-配置文件整合"><span class="nav-number">2.1.</span> <span class="nav-text">基于 xml 配置文件整合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认策略组件"><span class="nav-number">2.2.</span> <span class="nav-text">默认策略组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取默认的策略组件"><span class="nav-number">2.3.</span> <span class="nav-text">获取默认的策略组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpServletBean-init"><span class="nav-number">2.4.</span> <span class="nav-text">HttpServletBean.init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FrameworkServlet-initServletBean"><span class="nav-number">2.5.</span> <span class="nav-text">FrameworkServlet.initServletBean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化-WebApplicationContext"><span class="nav-number">2.5.1.</span> <span class="nav-text">初始化 WebApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程"><span class="nav-number">2.5.2.</span> <span class="nav-text">流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherServlet初始化策略类"><span class="nav-number">2.6.</span> <span class="nav-text">DispatcherServlet初始化策略类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化MultipartResolver"><span class="nav-number">2.6.1.</span> <span class="nav-text">初始化MultipartResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化LocaleResolver"><span class="nav-number">2.6.2.</span> <span class="nav-text">初始化LocaleResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化ThemeResolver"><span class="nav-number">2.6.3.</span> <span class="nav-text">初始化ThemeResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化HandlerMapping"><span class="nav-number">2.6.4.</span> <span class="nav-text">初始化HandlerMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化HandlerAdapter"><span class="nav-number">2.6.5.</span> <span class="nav-text">初始化HandlerAdapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化HandlerExceptionResolver"><span class="nav-number">2.6.6.</span> <span class="nav-text">初始化HandlerExceptionResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化RequestToViewNameTranslator"><span class="nav-number">2.6.7.</span> <span class="nav-text">初始化RequestToViewNameTranslator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化ViewResolver"><span class="nav-number">2.6.8.</span> <span class="nav-text">初始化ViewResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化FlashMapManager"><span class="nav-number">2.6.9.</span> <span class="nav-text">初始化FlashMapManager</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化流程"><span class="nav-number">2.7.</span> <span class="nav-text">初始化流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DispactherServlet处理请求"><span class="nav-number">3.</span> <span class="nav-text">DispactherServlet处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FrameworkServlet-service-方法"><span class="nav-number">3.1.</span> <span class="nav-text">FrameworkServlet.service 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FrameworkServlet-processRequest"><span class="nav-number">3.2.</span> <span class="nav-text">FrameworkServlet.processRequest</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalContext"><span class="nav-number">3.2.1.</span> <span class="nav-text">LocalContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestAttributes"><span class="nav-number">3.2.2.</span> <span class="nav-text">RequestAttributes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherServlet-doService方法"><span class="nav-number">3.3.</span> <span class="nav-text">DispatcherServlet.doService方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherServlet-doDispatch方法"><span class="nav-number">3.4.</span> <span class="nav-text">DispatcherServlet.doDispatch方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检查上传请求"><span class="nav-number">3.4.1.</span> <span class="nav-text">检查上传请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据request找到HandlerMapping"><span class="nav-number">3.4.2.</span> <span class="nav-text">根据request找到HandlerMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将handler包装为HandlerAdapter"><span class="nav-number">3.4.3.</span> <span class="nav-text">将handler包装为HandlerAdapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理-GET-POST-方法的-Last-Modification"><span class="nav-number">3.4.4.</span> <span class="nav-text">处理 GET/POST 方法的 Last-Modification</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行-HandlerExecutionChain-preHandler方法"><span class="nav-number">3.4.5.</span> <span class="nav-text">执行 HandlerExecutionChain#preHandler方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerAdapter调用handler的功能处理方法"><span class="nav-number">3.4.6.</span> <span class="nav-text">HandlerAdapter调用handler的功能处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步执行"><span class="nav-number">3.4.7.</span> <span class="nav-text">异步执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置默认视图名"><span class="nav-number">3.4.8.</span> <span class="nav-text">设置默认视图名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行-HandlerExecutionChain-postHandler方法"><span class="nav-number">3.4.9.</span> <span class="nav-text">执行 HandlerExecutionChain#postHandler方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行-processDispatchResult-方法"><span class="nav-number">3.4.10.</span> <span class="nav-text">执行 processDispatchResult 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#渲染视图"><span class="nav-number">3.4.10.1.</span> <span class="nav-text">渲染视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#触发请求处理完成通知"><span class="nav-number">3.4.10.2.</span> <span class="nav-text">触发请求处理完成通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理请求总体流程"><span class="nav-number">3.5.</span> <span class="nav-text">处理请求总体流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpServletBean"><span class="nav-number">4.1.</span> <span class="nav-text">HttpServletBean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FrameworkServlet："><span class="nav-number">4.2.</span> <span class="nav-text">FrameworkServlet：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">4.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理请求"><span class="nav-number">4.2.2.</span> <span class="nav-text">处理请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherServlet"><span class="nav-number">4.3.</span> <span class="nav-text">DispatcherServlet</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zuoshangan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
