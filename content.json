{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"zuoshangan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"SpringMVC","date":"2019-08-03T12:32:50.000Z","updated":"2019-08-03T12:32:50.591Z","comments":true,"path":"SpringMVC/index.html","permalink":"http://yoursite.com/SpringMVC/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-07-20T09:35:30.000Z","updated":"2019-07-20T09:53:18.136Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"archives","date":"2019-07-20T09:36:02.000Z","updated":"2019-07-20T09:36:02.060Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-07-20T09:35:36.000Z","updated":"2019-07-20T09:53:10.380Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2019-07-20T09:35:47.000Z","updated":"2019-07-20T09:52:53.466Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"DispatcherServlet 初始化和处理请求","slug":"DispatcherServlet-初始化和处理请求","date":"2019-08-03T12:34:45.000Z","updated":"2019-08-03T12:37:13.683Z","comments":true,"path":"2019/08/03/DispatcherServlet-初始化和处理请求/","link":"","permalink":"http://yoursite.com/2019/08/03/DispatcherServlet-初始化和处理请求/","excerpt":"","text":"DispatcherServlet初始化和处理请求DispatcherServlet 是前端控制器设计模式的实现，提供 Spring Web MVC 集中访问点，而且负责职责的分派，而且与 Spring IoC 容器无缝集成。 （1）DispatcherServlet 实现了 HttpServlet 接口，因此，DispatcherServlet 是一个 Servlet，那么它就遵循 Servlet 的生命周期； （2）DispatcherServlet 还实现 Aware接口，Spring 会自动注入 Aware 接口方法里的对象；但是 DispatcherServlet 对象由 Web 容器来管理，而不是由 Spring IOC 管理，因此，根本就不可能自动注入Environment 和 ApplicationContext 对象；这里的 ApplicationContextAware 和 EnvironmentAware 实际是作为普通接口使用，需要手动编程调用接口方法，如果 ServletContext.addServlet 方法注入 Servlet，如果注册的是 DispatcherServlet，那么就可以在 FrameworkServlet 及其子类通过构造方法时传入已经创建好的 WebApplicationContext；默认使用 WebApplicationContext 作为上下文，Spring默认配置文件为 “/WEBINF/[servlet名字]-servlet.xml“ （3）实现 EnvironmentCapacle 接口，表示 DispatcherServlet 具有 Environment 的能力，也就是可以提供 Environment，这是通过 getEnvironment() 方法获取 123456public interface EnvironmentCapable { // 返回Environment对象 Environment getEnvironment();} DispatcherServlet 主要用作职责调度工作，本身主要用于控制流程，主要职责如下： 1、文件上传解析，如果请求类型是 multipart 将通过 MultipartResolver 进行文件上传解析； 2、通过 HandlerMapping 将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor 拦截器）； 3、通过 HandlerAdapter 支持多种类型的处理器(HandlerExecutionChain 中的处理器)； 4、通过 ViewResolver 解析逻辑视图名到具体视图实现； 5、本地化解析； 6、渲染具体的视图等； 7、如果执行过程中遇到异常将交给 HandlerExceptionResolver 来解析； DispatcherServlet 的初始化和处理请求的流程图如下所示： 图片来源阿里大神博客[http://fangjian0423.github.io/2017/07/28/springmvc-process-write-by-processon/] DispatcherServlet中使用的特殊BeanDispatcherServlet 默认使用 WebApplicationContext 作为上下文，WebApplicationContext 上下文中有如下的特殊 bean： 1、Controller：处理器/页面控制器，做的是 MVC 中的 C 的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理； 2、HandlerMapping：请求到处理器的映射，如果映射成功返回一个 HandlerExecutionChain 对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器； 3、HandlerAdapter：HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理； 4、ViewResolver：ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为 jsp 视图； 5、LocalResover：本地化解析，因为Spring支持国际化，因此LocalResover解析客户端的Locale信息从而方便进行国际化； 6、ThemeResovler：主题解析，通过它来实现一个页面多套风格，即常见的类似于软件皮肤效果； 7、MultipartResolver：文件上传解析，用于支持文件上传； 8、HandlerExceptionResolver：处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息）； 9、RequestToViewNameTranslator：当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名； 10、FlashMapManager：用于管理FlashMap的策略接口，FlashMap用于存储一个请求的输出，当进入另一个请求时作为该请求的输入，通常用于重定向场景。 DispatcherServlet 初始化从 DispatcherServlet 的类图中可以看出，DispatcherServlet 是一个 Servlet，那么它就会遵从 Servlet 的规范，在初始化时会调用 Servlet 的 init 方法，本小节就从 Servlet#init 方法触发分析 DispatcherServlet 的初始化流程 基于 xml 配置文件整合下面是使用 xml 配置文件时 web.xml 文件的配置： 12345678910111213141516171819202122232425 contextConfigLocation classpath:spring-context.xml org.springframework.web.context.ContextLoaderListener springmvc org.springframework.web.servlet.DispatcherServlet 1 contextConfigLocation classpath:spring-servlet-config.xml springmvc / 其中，load-on-startup 的值（默认值为 0，）设置为 1，表示启动容器时初始化该 Servlet，数字表示容器初始化 Servlet 的顺序，值越小优先级越高，也就是说，loan-on-startup 的值越小，容器优先初始化该 Servlet。 URL 模式设置为 “/“ 时，所有的请求（包含静态资源）都会被映射到 DispatcherServlet，为了能正确处理静态资源，需要在 Spring MVC 配置文件中添加 标签来指明静态文件 Spring MVC 的配置文件为： 123456789 元素会注册控制器注解的 bean ， 元素表示哪些静态资源需要单独处理；如果没有 ， 元素会阻止任意控制器被调用，因此，如果不需要使用 resource，则不需要 元素。 默认策略组件在DispatcherServlet 中 defaultStrategies 字段存储了所有的默认策略组件，这些默认的策略组件在 DispatcherServlet 加载时就会读取 DispatcherServlet.properties 属性文件的内容，然后将其设置到 defaultStrategies 对象中 12345678910111213141516private static final String DEFAULT_STRATEGIES_PATH = \"DispatcherServlet.properties\";private static final Properties defaultStrategies;static { // 静态方法中读取DispatcherServlet.properties属性文件，并设置到defaultStrategies对象中 try { ClassPathResource resource = new ClassPathResource( DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); } catch (IOException ex) { throw new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage()); }} DispatcherServlet.properties 配置文件，配置了 SpringMVC 需要使用的默认策略组件，当没有配置 标签时，这些默认配置才会生效，当配置已经配置 标签，AnnotationDrivenBeanDefinitionParser 会创建某些策略组件，这些策略组件会覆盖默认的策略组件。 123456789101112131415161718192021222324# Default implementation classes for DispatcherServlet's strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\\ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager DispatcherServlet 也可以配置自己的初始化参数，覆盖默认配置： 1、contextClass：实现 WebApplicationContext 接口的类，当前的 Servlet 用它来创建上下文，如果没有指定 contextClass 参数，默认使用 XmlWebApplicationContext； 2、contextConfigLocation：指定上下文的位置，上下文实例（contextClass指定）的字符串，可以指定多个上下文，多个上下文使用逗号进行分割； 3、namespace：WebApplicationContext 命名空间，默认值是 “[server-name]-servlet”。 获取默认的策略组件从DispatcherServlet.properties 文件中可以看到有些策略组件有一个默认的实现，也有的组件有多个默认的实现，因此，在 DispatcherServlet 中提供了两个方法用于获取默认的策略组件：获取单个策略组件的 getDefaultStrategy 方法、获取多个策略组件的 getDefaultStrategies 方法。 获取单个策略组件的 getDefaultStrategy 方法： 1234567891011protected T getDefaultStrategy(ApplicationContext context, Class strategyInterface) { // 获取默认的策略组件 List strategies = getDefaultStrategies(context, strategyInterface); if (strategies.size() != 1) { throw new BeanInitializationException( \"DispatcherServlet needs exactly 1 strategy for interface [\" + strategyInterface.getName() + \"]\"); } return strategies.get(0);} 获取多个策略组件 getDefaultStrategies 方法： 1234567891011121314151617181920212223242526272829303132333435363738protected List getDefaultStrategies(ApplicationContext context, Class strategyInterface) { String key = strategyInterface.getName(); // 获取策略组件的类型 String value = defaultStrategies.getProperty(key); if (value != null) { // 存在多个策略组件实现类 String[] classNames = StringUtils.commaDelimitedListToStringArray(value); List strategies = new ArrayList(classNames.length); // 遍历所有的实现类 for (String className : classNames) { try { // 获取策略实现类的类名 Class clazz = ClassUtils.forName( className, DispatcherServlet.class.getClassLoader()); // 根据BeanDefinition进行实例 Object strategy = createDefaultStrategy(context, clazz); strategies.add((T) strategy); } catch (ClassNotFoundException ex) { throw new BeanInitializationException( \"Could not find DispatcherServlet's default strategy class [\" + className + \"] for interface [\" + key + \"]\", ex); } catch (LinkageError err) { throw new BeanInitializationException( \"Unresolvable class definition for DispatcherServlet's\" + \" default strategy class [\" + className + \"] for interface [\" + key + \"]\", err); } } return strategies; } // 如果 else { return new LinkedList(); }} HttpServletBean.initHttpServletBean 继承 HttpServlet 抽象类，继承 HttpServlet大部分的默认行为， HttpServletBean 主要作用 在 Web 容器启动时将调用它的 init 方法，将 DispatcherServlet 初始化参数（init-param）使用 BeanWrapper 设置到 DispatcherServlet 组件上，在初始化时将 DispatcherServlet 中的 标签的 子标签当做一个 bean； 标签用于设置 Servlet 的初始化参数，可以通过 getInitParameter(String name) 方法获取对应的初始化参数；它并没有处理请求，而是将请求处理留给子类实现。 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic final void init() throws ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Initializing servlet '\" + getServletName() + \"'\"); } // （1）将Servlet初始化参数设置到PropertyValue对象 PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) { try { BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); // 加载资源 ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); // 模板方法，可以在子类中调用，做初始化工作 initBeanWrapper(bw); // 将配置的初始化值设置到DispatcherServlet bw.setPropertyValues(pvs, true); } catch (BeansException ex) { if (logger.isErrorEnabled()) { logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); } throw ex; } } // （2）提供给子类初始化的扩展点，该方法由FrameworkServlet覆盖 initServletBean(); if (logger.isDebugEnabled()) { logger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\"); }} BeanWrapper 是 Spring 用来操作 Java bean 的工具类，可以直接修改 Java bean 的属性， 1234567891011121314151617181920212223242526public ServletConfigPropertyValues(ServletConfig config, Set requiredProperties) throws ServletException { Set missingProps = (!CollectionUtils.isEmpty(requiredProperties) ? new HashSet(requiredProperties) : null); // 读取Servlet的初始化参数 Enumeration paramNames = config.getInitParameterNames(); while (paramNames.hasMoreElements()) { String property = paramNames.nextElement(); Object value = config.getInitParameter(property); // 初始化参数封装成PropertyValue对象 addPropertyValue(new PropertyValue(property, value)); if (missingProps != null) { missingProps.remove(property); } } // 初始化失败 if (!CollectionUtils.isEmpty(missingProps)) { throw new ServletException( \"Initialization from ServletConfig for servlet '\" + config.getServletName() + \"' failed; the following required properties were missing: \" + StringUtils.collectionToDelimitedString(missingProps, \", \")); }} FrameworkServlet.initServletBeaninitServletBean() 方法时父类 HttpServletBean 提供的模板方法，它在 HttpServletBean的初始化入口方法 init() 方法中调用， 123456789101112131415161718192021222324252627282930protected final void initServletBean() throws ServletException { getServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\"); if (this.logger.isInfoEnabled()) { this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\"); } long startTime = System.currentTimeMillis(); try { // (1)初始化Web应用上下文 this.webApplicationContext = initWebApplicationContext(); // (2)提供给子类初始化FrameworkServlet的模板方法 initFrameworkServlet(); } catch (ServletException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } catch (RuntimeException ex) { this.logger.error(\"Context initialization failed\", ex); throw ex; } if (this.logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" + elapsedTime + \" ms\"); }} FrameworkServlet.initServletBean() 方法的作用功能是完成如下两个方面的任务： 初始化 WebApplicationContext； 提供一个模板方法 initFrameworkServlet() 方法初始化 FrameworkServlet，默认为空实现，由子类实现； 初始化 WebApplicationContext其中，WebApplicationContext 表示 Web 环境的上下文对象，初始化 web 上下文为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected WebApplicationContext initWebApplicationContext() { // (1)使用ContextLoaderListener所加载的根上下文 WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // (2)使用Servlet构造函数注册的Web应用上下文 wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { if (cwac.getParent() == null) { cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // (3)使用contextAttribute值指定的ServletContext上下文中的Web应用上下文 wac = findWebApplicationContext(); } if (wac == null) { // (4)DispatcherServlet中init-param指定的contextConfigLocation所加载的Web应用上下文 // 如果没有找到相应的上下文，并指定父亲为ContextLoaderListener加载的Web应用上下文 wac = createWebApplicationContext(rootContext); } // ContextRefreshEvent还没触发则刷新容器 if (!this.refreshEventReceived) { // (5)刷新上下文（初始化SpringMVC的基础组件），由子类（DispatcherServlet）实现 synchronized (this.onRefreshMonitor) { onRefresh(wac); } } if (this.publishContext) { // (6)将Web应用上下文，存储在ServletContext上下文中 // 这里的 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); } return wac;} 注意：这里的 Web 应用上下文，指的是 Spring 的 WebApplicationContext 对象 从 initWebApplicationContext() 方法的主要作用为： 获取 ContextLoaderListener 加载的 Spring 根容器 rootContext； 设置 WebApplicationContext，如果 ContextRefreshedEvent 事件还没触发则调用 onRefresh() 方法刷新容器； 将 WebApplicationContext 对象作为 ServletContext 一个属性设置到 ServletContext 中，方便在后续中获取 Spring 容器。 基本上如果 ContextLoaderListener 加载了上下文将作为根上下文（即 DispatcherServlet 的父容器）。 （1）获取 Spring 根容器 rootContext 123456789101112131415161718192021222324252627282930313233String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + \".ROOT\";public static WebApplicationContext getWebApplicationContext(ServletContext sc) { return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);}@Nullablepublic static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) { Assert.notNull(sc, \"ServletContext must not be null\"); // 从ServletContext中获取 Object attr = sc.getAttribute(attrName); if (attr == null) { return null; } if (attr instanceof RuntimeException) { throw (RuntimeException) attr; } if (attr instanceof Error) { throw (Error) attr; } if (attr instanceof Exception) { throw new IllegalStateException((Exception) attr); } if (!(attr instanceof WebApplicationContext)) { throw new IllegalStateException( \"Context attribute is not of type WebApplicationContext: \" + attr); } return (WebApplicationContext) attr;} 可以看到获取根容器 rootContext 是直接以 org.springframework.web.context.WebApplicationContext.ROOT 作为键从 ServletContext 中获取，也就是说默认情况下，Spring 的根容器为作为一个属性存储在 ServletContext中，它的键为 org.springframework.web.context.WebApplicationContext.ROOT； （2）调用 onRefresh() 方法 创建 WebApplicationContext ： 123protected WebApplicationContext createWebApplicationContext(WebApplicationContext parent) { return createWebApplicationContext((ApplicationContext) parent);} 12345678910111213141516171819202122232425protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) { // 在web.xml文件中指定DispatcherServlet的contextClass属性值 Class contextClass = getContextClass(); // 如果指定Web上下文不是ConfigurableWebApplicationContext子类则抛出异常 if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( \"Fatal initialization error in servlet with name '\" + getServletName() + \"': custom WebApplicationContext class [\" + contextClass.getName() + \"] is not of type ConfigurableWebApplicationContext\"); } ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); // 设置环境 wac.setEnvironment(getEnvironment()); // 设置WebApplicationContext的父容器 wac.setParent(parent); // 如果在web.xml文件中指定DispatcherServlet的contextConfigLocation属性值 String configLocation = getContextConfigLocation(); if (configLocation != null) { wac.setConfigLocation(configLocation); } configureAndRefreshWebApplicationContext(wac); return wac;} 创建 WebApplicationContext 的三种方法： 在 Servlet3.0 后通过 ServletContext.addServlet 注册 DispatcherServlet 时，在 DispatcherServlet 的构造方法中会创建 WebApplicationContext。 WebApplicationContext 已经存在 ServletConetxt 中，则通过 DispatcherServlet的contextAttribute 属性值获取 WebApplicationContext 对象 12345678910111213 dispatcherServlet org.springframework.web.servlet.DispatcherServlet 1 contextAttribute springmvc springmvc / 在前面两种方法都没有创建 WebApplicationContext 时调用 createWebApplicationContext 方法创建 WebApplicationContext ： 123protected WebApplicationContext createWebApplicationContext(WebApplicationContext parent) { return createWebApplicationContext((ApplicationContext) parent);} 12345678910111213141516171819202122232425protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) { // 在web.xml文件中指定DispatcherServlet的contextClass属性值 Class contextClass = getContextClass(); // 如果指定Web上下文不是ConfigurableWebApplicationContext子类则抛出异常 if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( \"Fatal initialization error in servlet with name '\" + getServletName() + \"': custom WebApplicationContext class [\" + contextClass.getName() + \"] is not of type ConfigurableWebApplicationContext\"); } ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); // 设置环境 wac.setEnvironment(getEnvironment()); // 设置WebApplicationContext的父容器 wac.setParent(parent); // 如果在web.xml文件中指定DispatcherServlet的contextConfigLocation属性值 String configLocation = getContextConfigLocation(); if (configLocation != null) { wac.setConfigLocation(configLocation); } configureAndRefreshWebApplicationContext(wac); return wac;} 123456789101112131415161718192021222324252627282930313233protected void configureAndRefreshWebApplicationContext( ConfigurableWebApplicationContext wac) { if (ObjectUtils.identityToString(wac).equals(wac.getId())) { // The application context id is still set to its original default value // -> assign a more useful id based on available information if (this.contextId != null) { wac.setId(this.contextId); } else { // Generate default id... wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName()); } } wac.setServletContext(getServletContext()); wac.setServletConfig(getServletConfig()); wac.setNamespace(getNamespace()); // 添加ContextRefreshedEvent事件监听器 wac.addApplicationListener( new SourceFilteringListener(wac, new ContextRefreshListener())); ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) { ((ConfigurableWebEnvironment) env).initPropertySources( getServletContext(), getServletConfig()); } postProcessWebApplicationContext(wac); applyInitializers(wac); wac.refresh();} ContextRefreshedEvent事件监听器监听的是 ContextRefreshListener 事件， 12345678private class ContextRefreshListener implements ApplicationListener { @Override public void onApplicationEvent(ContextRefreshedEvent event) { FrameworkServlet.this.onApplicationEvent(event); }} 123456public void onApplicationEvent(ContextRefreshedEvent event) { this.refreshEventReceived = true; synchronized (this.onRefreshMonitor) { onRefresh(event.getApplicationContext()); }} 当接受到消息时调用 FrameworkServlet 的 onApplicationEvent 方法，在 onApplicationEvent 方法中会将 refreshEventReceived 标识设置为true，然后调用 FrameworkServlet.onRefresh 方法，onRefresh() 方法是一个模板方法，只会被调用一次，DispatcherServlet 就是通过 onRefresh() 方法来完成初始化的。 12345678910111213141516@Overrideprotected void onRefresh(ApplicationContext context) { initStrategies(context);}protected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);} （3）将 WebApplicationContext 设置到 ServletContext 中， 流程（1）使用 ContextLoaderListener 加载的 Web 应用上下文，是在 web.xml 中构造父子容器的常见方案 123456789 contextConfigLocation classpath:spring-context.xml org.springframework.web.context.ContextLoaderListener （2）使用 Servlet 构造函数注册的 Web 应用上下文 1234public DispatcherServlet(WebApplicationContext webApplicationContext) { super(webApplicationContext); setDispatchOptionsRequest(true);} 这里调用父类的构造方法就是调用 FrameworkServlet 的构造方法 123public FrameworkServlet(WebApplicationContext webApplicationContext) { this.webApplicationContext = webApplicationContext;} （3）使用 contextAttribute 属性值指定的 ServletContext 上下文中的 Web 应用上下文；这种方式比较少见。 从 ServletContext 上下文中去找一个 key 为 myWebApplicationContext 的 Web 应用上下文，来作为 DispatcherServlet 对象中的 webApplicationContext 属性的值，当然，前提是 ServletContext 上下文中放置过该 Web 应用上下文对象 123456789 dispatcherServlet org.springframework.web.servlet.DispatcherServlet contextAttribute myWebApplicationContext 1 12345678910111213// 使用contextAttribute值指定的ServletContext上下文中的Web应用上下文protected WebApplicationContext findWebApplicationContext() { String attrName = getContextAttribute(); if (attrName == null) { return null; } WebApplicationContext wac = WebApplicationContextUtils .getWebApplicationContext(getServletContext(), attrName); if (wac == null) { throw new IllegalStateException(\"No WebApplicationContext found: initializer not registered?\"); } return wac;} （4）在 DispatcherServlet 中 init-param 指定的 contextConfigLocation 所加载的 Web 应用上下文，这种配置是比较常见的配置 Web 应用上下文 的方式： 12345678910111213 springmvc org.springframework.web.servlet.DispatcherServlet 1 contextConfigLocation classpath:spring-mvc.xml springmvc / 根据 contextConfigLocation 创建的 Web 应用上下文 123protected WebApplicationContext createWebApplicationContext(WebApplicationContext parent) { return createWebApplicationContext((ApplicationContext) parent);} 12345678910111213141516171819202122232425262728protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) { // 获取标签 Class contextClass = getContextClass(); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Servlet with name '\" + getServletName() + \"' will try to create custom WebApplicationContext context of class '\" + contextClass.getName() + \"'\" + \", using parent context [\" + parent + \"]\"); } if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( \"Fatal initialization error in servlet with name '\" + getServletName() + \"': custom WebApplicationContext class [\" + contextClass.getName() + \"] is not of type ConfigurableWebApplicationContext\"); } // 实例化 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); wac.setParent(parent); // 设置配置文件路径，即contextConfigLocation指定 wac.setConfigLocation(getContextConfigLocation()); configureAndRefreshWebApplicationContext(wac); return wac;} 123456789101112131415161718192021222324252627282930313233protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) { if (ObjectUtils.identityToString(wac).equals(wac.getId())) { // The application context id is still set to its original default value // -> assign a more useful id based on available information if (this.contextId != null) { wac.setId(this.contextId); } else { // Generate default id... wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName()); } } wac.setServletContext(getServletContext()); wac.setServletConfig(getServletConfig()); wac.setNamespace(getNamespace()); wac.addApplicationListener(new SourceFilteringListener( wac, new ContextRefreshListener())); ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) { ((ConfigurableWebEnvironment) env) .initPropertySources(getServletContext(), getServletConfig()); } postProcessWebApplicationContext(wac); // 执行web.xml中init-param指定的ApplicationContextInitializer的实现类初始化方法 applyInitializers(wac); // Spring容器的刷新方法 wac.refresh();} wac.refresh() 是 Spring 容器的启动刷新方法，它会扫描 所指定目录下的 @Component、@Service、@Controller、@Repository、@Configuration所标注的类。 经过 （1）-（4）这四个步骤后 WebApplicationContext 就创建完毕了。 （5）初始化 Spring MVC 的基础组件 如果配置 标签，则使用 标签所绑定的 Spring MVC 基础组件；如果没有配置 标签，则使用 DispatcherServlet.properties 配置文件内默认的 Spring MVC 基础组件 。 123protected void onRefresh(ApplicationContext context) { // For subclasses: do nothing by default.} onRefresh 方法在 FrameworkServlet 中为空实现，具体地实现由 DispatcherServlet 实现。 （6）将 Web 应用上下文，存储在 ServletContext 上下文中 123456public static final String SERVLET_CONTEXT_PREFIX = FrameworkServlet.class.getName() + \".CONTEXT.\";public String getServletContextAttributeName() { return SERVLET_CONTEXT_PREFIX + getServletName();} 这里的 getServletName() 方法返回的就是 Servlet 的名称，这个名称使我们在 web.xml 文件里配置的，比如本例中存储在 ServeltContext 的 Web 应用上下文的 key 为 1org.springframework.web.servlet.FrameworkServlet.CONTEXT.springmvc 存储在 ServletContext 中的 Web 应用上下文可以通过 getAttribute(String name) 方法来获取，比如本例中： 12WebApplicationContext wac = (WebApplicationContext) servletContext .getAttribute(\"org.springframework.web.servlet.FrameworkServlet.CONTEXT.springmvc\") 经过上面的六个步骤后，WebApplicationContext 对象存在于 DispatcherServlet 对象中，也存在于 ServletContext 上下文中，ServletContext对象，就是传说中的 global session，也就是 jsp 中的 application 对象。WebApplicationContext 上下文对象中，也存储了 ServletContext 和 ServletConfig 对象。 DispatcherServlet初始化策略类DispatcherServlet.onRefresh 方法是 DispatcherServlet 的入口方法，DispatcherServlet.initStrategies 方法中初始化默认九个策略组件： 1234567891011121314151617181920212223242526@Overrideprotected void onRefresh(ApplicationContext context) { initStrategies(context);}// 初始化DispatcherServlet默认的九个策略组件protected void initStrategies(ApplicationContext context) { // 配置文件上传接口 initMultipartResolver(context); // 配置本地化解析 initLocaleResolver(context); // 配置主题解析 initThemeResolver(context); // 配置映射处理器 initHandlerMappings(context); // 配置HandlerAdapter initHandlerAdapters(context); // 配置处理器异常解析 initHandlerExceptionResolvers(context); // 配置RequestToViewNameTranslator initRequestToViewNameTranslator(context); // 配置驶入解析器 initViewResolvers(context); // 配置FlashMap initFlashMapManager(context);} DispatcherServlet 启动时会进行配置需要的 Web 层 bean，如 HandlerMapping 、 HandlerAdapter 等，而且如果我们没有配置，还会给我们提供默认的配置。 初始化MultipartResolverinitMultipartResolver 方法初配置文件上传解析，由于并不是所有的请求都是上传文件请求，因此，默认的情况下， DispatcherServlet.properties 文件中没有提供 MultipartResolver 的实现类。 当请求为上传文件的请求时，必须手动注册MultipartResolver。 12345678910111213141516171819public static final String MULTIPART_RESOLVER_BEAN_NAME = \"multipartResolver\";private void initMultipartResolver(ApplicationContext context) { try { // 从IoC容器中获取MultipartResolver组件，如果不存在则创建 this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class); if (logger.isDebugEnabled()) { logger.debug(\"Using MultipartResolver [\" + this.multipartResolver + \"]\"); } } catch (NoSuchBeanDefinitionException ex) { this.multipartResolver = null; if (logger.isDebugEnabled()) { logger.debug(\"Unable to locate MultipartResolver with name '\" + MULTIPART_RESOLVER_BEAN_NAME + \"': no multipart request handling provided\"); } }} 初始化LocaleResolver先判断是否手动指定注册 LocaleResolver，如果手动指定 LocaleResolver，则从 IoC 容器中获取指定的 LocaleResolver，否则加载默认的 AcceptHeaderLocaleResolver。 123456789101112131415161718192021222324public static final String LOCALE_RESOLVER_BEAN_NAME = \"localeResolver\";private void initLocaleResolver(ApplicationContext context) { try { // 从IoC容器中获取LOcaleResolver this.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class); if (logger.isTraceEnabled()) { logger.trace(\"Detected \" + this.localeResolver); } else if (logger.isDebugEnabled()) { logger.debug(\"Detected \" + this.localeResolver.getClass().getSimpleName()); } } catch (NoSuchBeanDefinitionException ex) { // 如果IoC容器中LocalResolver对应BeanDefinition，则使用默认的策略类 this.localeResolver = getDefaultStrategy(context, LocaleResolver.class); if (logger.isTraceEnabled()) { logger.trace(\"No LocaleResolver '\" + LOCALE_RESOLVER_BEAN_NAME + \"': using default [\" + this.localeResolver.getClass().getSimpleName() + \"]\"); } }} 初始化ThemeResolver先判断是否手动指定注册 ThemeResolver，如果手动指定 ThemeResolver，则从 IoC 容器中获取指定的 LocaleResolver，否则加载默认的 FixedThemeResolver。 12345678910111213141516171819202122private void initThemeResolver(ApplicationContext context) { try { // 从IoC容器中获取ThemeResolver this.themeResolver = context.getBean(THEME_RESOLVER_BEAN_NAME, ThemeResolver.class); if (logger.isTraceEnabled()) { logger.trace(\"Detected \" + this.themeResolver); } else if (logger.isDebugEnabled()) { logger.debug(\"Detected \" + this.themeResolver.getClass().getSimpleName()); } } catch (NoSuchBeanDefinitionException ex) { // 当IoC容器没有ThemeResolver对应的BeanDefinition，则使用默认的 this.themeResolver = getDefaultStrategy(context, ThemeResolver.class); if (logger.isTraceEnabled()) { logger.trace(\"No ThemeResolver '\" + THEME_RESOLVER_BEAN_NAME + \"': using default [\" + this.themeResolver.getClass().getSimpleName() + \"]\"); } }} 初始化HandlerMapping先判断是否手动指定注册 HandlerMapping，如果手动指定 HandlerMapping，则从 IoC 容器中获取指定的 HandlerMapping，否则加载默认的两个：BeanNameUrlHandlerMapping、RequestMappingHandlerMapping。 1234567891011121314151617181920212223242526272829303132333435363738public static final String HANDLER_MAPPING_BEAN_NAME = \"handlerMapping\";private void initHandlerMappings(ApplicationContext context) { this.handlerMappings = null; // detectAllHandlerMappings默认为true if (this.detectAllHandlerMappings) { // 在ApplicationContext中查找所有HandlerMappings，包括祖先上下文。 Map matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); // 如果容器中有HandlerMapping组件则将HandlerMapping组件添加到handlerMappings集合中 if (!matchingBeans.isEmpty()) { this.handlerMappings = new ArrayList(matchingBeans.values()); // 对HandlerMapping进行排序 AnnotationAwareOrderComparator.sort(this.handlerMappings); } } else { try { // 查找键为handlerMapping的HandlerMapping对象，包含祖先容器上下文 HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); this.handlerMappings = Collections.singletonList(hm); } catch (NoSuchBeanDefinitionException ex) { } } // 如果没有配置，取DispatcherServlet.properties中的默认配置 if (this.handlerMappings == null) { this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); if (logger.isDebugEnabled()) { logger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\"); } }} 初始化HandlerAdapterSpring MVC 会默认注册三个 HandlerAdapter： HttpRequestHandlerAdapter HttpRequestHandlerAdapter RequestMappingHandlerAdapter 123456789101112131415161718192021222324252627282930313233343536private void initHandlerAdapters(ApplicationContext context) { this.handlerAdapters = null; // 如果自动检测HandlerAdapter，默认是自动检测容器中的HandlerAdapter if (this.detectAllHandlerAdapters) { // 在ApplicationContext中查找所有HandlerAdapter，包括祖先上下文 Map matchingBeans = BeanFactoryUtils .beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false); if (!matchingBeans.isEmpty()) { this.handlerAdapters = new ArrayList(matchingBeans.values()); // 排序 AnnotationAwareOrderComparator.sort(this.handlerAdapters); } } else { try { // 从IoC容器中获取指定beanName的HandlerAdapter HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class); this.handlerAdapters = Collections.singletonList(ha); } catch (NoSuchBeanDefinitionException ex) { } } // 如果没有注册HadnlerAdapter，则加载默认的HandlerAdapter if (this.handlerAdapters == null) { this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class); if (logger.isTraceEnabled()) { logger.trace(\"No HandlerAdapters declared for servlet '\" + getServletName() + \"': using default strategies from DispatcherServlet.properties\"); } }} 初始化HandlerExceptionResolver如果没有指定 HandlerExceptionResolver，Spring MVC 会加载默认的三个 HandlerExceptionResolver： ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver 123456789101112131415161718192021222324252627282930313233343536373839private void initHandlerExceptionResolvers(ApplicationContext context) { this.handlerExceptionResolvers = null; /** * 从IoC容器中加载HandlerExceptionResolver */ if (this.detectAllHandlerExceptionResolvers) { // 在ApplicationContext中查找所有HandlerExceptionResolver，包括祖先上下文 Map matchingBeans = BeanFactoryUtils .beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false); if (!matchingBeans.isEmpty()) { this.handlerExceptionResolvers = new ArrayList(matchingBeans.values()); // We keep HandlerExceptionResolvers in sorted order. AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers); } } else { try { HandlerExceptionResolver her = context.getBean( HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class); this.handlerExceptionResolvers = Collections.singletonList(her); } catch (NoSuchBeanDefinitionException ex) { } } // 如果没有手动注册HandlerExceptionResolver，则加载默认三个HandlerExceptionResolver if (this.handlerExceptionResolvers == null) { this.handlerExceptionResolvers = getDefaultStrategies( context, HandlerExceptionResolver.class); if (logger.isTraceEnabled()) { logger.trace(\"No HandlerExceptionResolvers declared in servlet '\" + getServletName() + \"': using default strategies from DispatcherServlet.properties\"); } }} 初始化RequestToViewNameTranslator如果没有手动注册 RequestToViewNameTranslator，那么就会从DispatcherServlet.properties 文件中加载默认的 DefaultRequestToViewNameTranslator 12345678910111213141516171819202122232425private void initRequestToViewNameTranslator(ApplicationContext context) { try { this.viewNameTranslator = context.getBean( REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, RequestToViewNameTranslator.class); if (logger.isTraceEnabled()) { logger.trace(\"Detected \" + this.viewNameTranslator.getClass().getSimpleName()); } else if (logger.isDebugEnabled()) { logger.debug(\"Detected \" + this.viewNameTranslator); } } catch (NoSuchBeanDefinitionException ex) { // 加载默认的RquestToViewNameTranslator this.viewNameTranslator = getDefaultStrategy( context, RequestToViewNameTranslator.class); if (logger.isTraceEnabled()) { logger.trace(\"No RequestToViewNameTranslator '\" + REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME + \"': using default [\" + this.viewNameTranslator.getClass().getSimpleName() + \"]\"); } }} 初始化ViewResolver如果手动指定了 ViewResolver，则从 IoC 容器中获取指定的 ViewResolver，如果没有手动注册，则加载默认的 InternalResourceViewResolver 123456789101112131415161718192021222324252627282930313233343536private void initViewResolvers(ApplicationContext context) { this.viewResolvers = null; /** * 先从IoC容器查找是否手动注册ViewResolver */ if (this.detectAllViewResolvers) { Map matchingBeans = BeanFactoryUtils .beansOfTypeIncludingAncestors(context, ViewResolver.class, true, false); if (!matchingBeans.isEmpty()) { this.viewResolvers = new ArrayList(matchingBeans.values()); // We keep ViewResolvers in sorted order. AnnotationAwareOrderComparator.sort(this.viewResolvers); } } else { try { ViewResolver vr = context.getBean( VIEW_RESOLVER_BEAN_NAME, ViewResolver.class); this.viewResolvers = Collections.singletonList(vr); } catch (NoSuchBeanDefinitionException ex) { // Ignore, we'll add a default ViewResolver later. } } // 如果没有手动注册ViewResolver，则加载默认的InternalResourceViewResolver if (this.viewResolvers == null) { this.viewResolvers = getDefaultStrategies(context, ViewResolver.class); if (logger.isTraceEnabled()) { logger.trace(\"No ViewResolvers declared for servlet '\" + getServletName() + \"': using default strategies from DispatcherServlet.properties\"); } }} 初始化FlashMapManagerFlashMapManager 用于解决 HTTP 重定向请求的时候，被存储到请求数据不会丢失，使得下一次GET请求可以访问到上一次请求中的一些有用的信息，Spring MVC 默认使用 SessionFlashMapManager。 12345678910111213141516171819202122private void initFlashMapManager(ApplicationContext context) { try { this.flashMapManager = context.getBean( FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class); if (logger.isTraceEnabled()) { logger.trace(\"Detected \" + this.flashMapManager.getClass().getSimpleName()); } else if (logger.isDebugEnabled()) { logger.debug(\"Detected \" + this.flashMapManager); } } catch (NoSuchBeanDefinitionException ex) { // We need to use the default. this.flashMapManager = getDefaultStrategy(context, FlashMapManager.class); if (logger.isTraceEnabled()) { logger.trace(\"No FlashMapManager '\" + FLASH_MAP_MANAGER_BEAN_NAME + \"': using default [\" + this.flashMapManager.getClass().getSimpleName() + \"]\"); } }} 初始化流程整个 DispatcherServlet 初始化的过程主要做了如下两件事情： 1、Spring MVC 中的 Servlet 一共有三个层次，分别是 HttpServletBean、FrameworkServlet、DispatcherServlet； 2、HttpServletBean 继承 HttpServlet，将 Servlet 中配置的参数设置到相应的属性中； 3、FrameworkServlet 初始化 WebApplicationContext，也就是初始化 Spring MVC 使用的 Web 上下文，并且可能指定父容器为（ContextLoaderListener 加载的根上下文）； 2、DispatcherServlet 根据 DispatcherServlet.properties 属性文件初始化默认的九个策略组件，如 MultipartResolver、LocaleResolver、ThemeResolver、HandlerMapping、HandlerAdapter、HandlerExceptionResolver、RequestToViewNameTranslator、ViewResolver、FlashMapManager（用于重定向时传递属性）。 DispatcherServlet 整个初始化流程为： Servlet.init(ServletConfig) –> GenericServlet.init –> HttpServlet.init() –> HttpServletBean.init() –> FrameworkSerlvlet.initServletBean() –> FrameworkSerlvlet.initWebApplicationContext() –> DispatcherSerlvlet.onRefresh() –> FrameworkSerlvlet.initFrameworkServlet() 从流程图中可以，DispatcherServlet 的初始化时通过模板方法来实现，GenericServlet 提供 init 模板方法，HttpServletBean 中重写 init 方法，在 HttpServletBean 中定义 initServletBean 模板方法，FrameworkServlet 中 定义 onRefresh 模板方法，DispatcherServlet 重写 onRefresh 方法，在 onRefresh 方法中调用 initStrategies 方法加载默认的策略类。 DispactherServlet处理请求 在前面分析到 DispactherServlet 的初始化工作时一个三层结构，涉及到 HttpServletBean、FrameworkServlet、DispatcherServlet； Servlet 的处理请求的入口方法是 Servlet 的 service(ServletRequest request, ServletResponse response) 方法，在 HttpServlet 中将 ServletRequest、ServletResponse 对象转换为 HttpServletRequest 、HttpServletResponse 对象，从而根据 HTTP 的请求类型将不同请求的路由到对应的 doGet、doPost、doHead、doPut 等模板方法，子类只需要重写模板方法即可。 在 HttpServletBean 的源码中并没有发现它重写 service 方法，也就说 HttpServletBean 并不处理请求，直接使用父类的 service(HttpServletRequest request, HttpServletResponse response) 方法，HttpServletBean 的主要是初始化 Servlet 的工作，而没有涉及到请求的处理工作。 FrameworkServlet.service 方法FrameworkServlet 重写了 HttpServlet 的 service 方法：增加了对 PATCH 请求类型的处理（PATCH 请求用于资源的部分更新，而PUT 用于更新资源完整的内容），其他的都是直接交给父类 HttpServlet 处理，而在父类 HttpServlet 的 service 方法中会调用 FrameworkServlet 重写 doXxx 方法： 12345678910111213protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); // 如果是PATCH方法（资源的部分更新） if (httpMethod == HttpMethod.PATCH || httpMethod == null) { processRequest(request, response); } // 直接交给父类处理，父类会调用FrameworkServlet重写的doXxx方法 else { super.service(request, response); }} FrameworkServlet 除了没有重写 doHead 方法外，重写了 doGet、doPost、doPut、doDelete、doOptions、doTrace 方法。 123456789101112131415161718192021222324252627@Overrideprotected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { processRequest(request, response);}@Overrideprotected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { processRequest(request, response);}@Overrideprotected final void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { processRequest(request, response);}@Overrideprotected final void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { processRequest(request, response);} doGet、doPost、doPut、doDelete 方法都是通过 processRequest(HttpServletRequest request, HttpServletResponse response) 同一处理；而 doOptions、doTrace 方法通过设置 dispatchOptionsRequest 和 dispatchTraceRequest 参数来决定自己处理还是交给父类处理，默认是交给父类处理。 1234567891011121314151617181920212223242526272829303132333435363738@Overrideprotected void doOptions(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { if (this.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) { processRequest(request, response); if (response.containsHeader(\"Allow\")) { // Proper OPTIONS response coming from a handler - we're done. return; } } // Use response wrapper in order to always add PATCH to the allowed methods super.doOptions(request, new HttpServletResponseWrapper(response) { @Override public void setHeader(String name, String value) { if (\"Allow\".equals(name)) { value = (StringUtils.hasLength(value) ? value + \", \" : \"\") + HttpMethod.PATCH.name(); } super.setHeader(name, value); } });}@Overrideprotected void doTrace(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { if (this.dispatchTraceRequest) { processRequest(request, response); if (\"message/http\".equals(response.getContentType())) { // Proper TRACE response coming from a handler - we're done. return; } } super.doTrace(request, response);} FrameworkServlet.processRequest在前面分析到 FrameworkServlet 的doGet、doPost、doPut、doDelete 方法都是通过 processRequest 同一处理；这里会发现 HttpServlet 将不同类型的请求路由到不同的方法里进行处理，而 FrameworkServlet 却将所有的请求都合并到 processRequest 方法中进行处理，这里的一个重要原因就是：Spring MVC 将不同的请求使用不同的 Handler 进行处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { long startTime = System.currentTimeMillis(); Throwable failureCause = null; // 获取LocaleContextHolder中保存的LocaleContext LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); // 创建当前请求的LocaleContext LocaleContext localeContext = buildLocaleContext(request); // 获取RequestContextHolder中保存的RequestAttributes RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); // 创建当前请求的ServletRequestAttributes ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); // 处理异步请求的异步管理器 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); // 注册拦截当前请求的拦截器CallableProcessingInterceptor asyncManager.registerCallableInterceptor( FrameworkServlet.class.getName(), new RequestBindingInterceptor()); // 将当前请求的LocaleContext和ServletRequestAttributes // 分别设置到LocalContextHolder和RequestContextHolder中 initContextHolders(request, localeContext, requestAttributes); try { // 实例处理请求的入口方法：这是一个模板方法，由子类实现 doService(request, response); } catch (ServletException | IOException ex) { failureCause = ex; throw ex; } catch (Throwable ex) { failureCause = ex; throw new NestedServletException(\"Request processing failed\", ex); } finally { // 恢复原来的LocaleContext和ServletRequestAttributes到LocalContextHolder // 和RequestContextHolder中 resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) { // 标记当前请求处理完成 requestAttributes.requestCompleted(); } logResult(request, response, failureCause, asyncManager); // 发布ServletRequestHandledEvent事件 publishRequestHandledEvent(request, response, startTime, failureCause); }} 分析源码可以看出，processRequest方法的流程比较清晰，主要做如下几件事： 1、获取LocaleContextHolder 和 RequestContextHolder中保存的 LocaleContext 和 RequestAttributes对象，并暂存它们，然后根据它们创建当前请求的 LocaleContext 和 ServletRquestAttributes 对象； 2、将当前请求的 LocaleContext 和 ServletRequestAttributes 分别设置到 LocalContextHolder 和 RequestContextHolder 中； 3、调用子类重写的 doService(request, response) 方法处理请求； 4、处理完请求后恢复原来的 LocaleContext 和 ServletRequestAttributes 对象，即将它们保存到 LocalContextHolder 和 RequestContextHolder 中，以便下次请求到来时再次获取； 12345678private void resetContextHolders(HttpServletRequest request, LocaleContext prevLocaleContext, RequestAttributes previousAttributes) { LocaleContextHolder.setLocaleContext( prevLocaleContext, this.threadContextInheritable); RequestContextHolder.setRequestAttributes( previousAttributes, this.threadContextInheritable);} 5、标记当前请求已经处理完成； 12345public void requestCompleted() { executeRequestDestructionCallbacks(); updateAccessedSessionAttributes(); this.requestActive = false;} 6、无论请求是否执行成功都会发布 ServletRequestHandledEvent 事件 1234567891011121314private void publishRequestHandledEvent(HttpServletRequest request, HttpServletResponse response, long startTime, Throwable failureCause) { // publishEvents默认为true if (this.publishEvents && this.webApplicationContext != null) { long processingTime = System.currentTimeMillis() - startTime; this.webApplicationContext.publishEvent( new ServletRequestHandledEvent(this, request.getRequestURI(), request.getRemoteAddr(), request.getMethod(), getServletConfig().getServletName(), WebUtils.getSessionId(request), getUsernameForRequest(request), processingTime, failureCause, response.getStatus())); }} LocalContext1234567public interface LocaleContext { // 获取Locale @Nullable Locale getLocale();} LocalContext 的作用作用是获取 LocalConext， 123456789101112131415161718192021public final class LocaleContextHolder { private static final ThreadLocal localeContextHolder = new NamedThreadLocal(\"LocaleContext\"); private static final ThreadLocal inheritableLocaleContextHolder = new NamedInheritableThreadLocal(\"LocaleContext\"); @Nullable private static Locale defaultLocale; @Nullable private static TimeZone defaultTimeZone; private LocaleContextHolder() { } .........} LocalContextHolder 持有 LocalContext 的引用，还可以获取 Locale 和 TimeZone 。它使用 ThreadLocal 保证每个线程都有一份 LocaleContext 的引用，当我们想要在其他地方使用的时候就可以直接通过 LocaleContextHolder.getLocalContext() 方法获取。 同理，RequestContextHolder 也是一样的，可以在任何地方通过 RequestContextHolder.getRequestAttributes() 方法获取 RequestAttributes 对象。 RequestAttributesRequestAttributes 用于管理 HttpServletRqeuest 和 HttpSession 的属性，可以通过 RequestAttributes 获取 HttpServletRequest、HttpServletResponse 、HttpSession 对象。 1234567891011121314151617181920212223242526272829public interface RequestAttributes { // reqeust作用域 int SCOPE_REQUEST = 0; // session作用域 int SCOPE_SESSION = 1; String REFERENCE_REQUEST = \"request\"; String REFERENCE_SESSION = \"session\"; Object getAttribute(String name, int scope); void setAttribute(String name, Object value, int scope); void removeAttribute(String name, int scope); String[] getAttributeNames(int scope); void registerDestructionCallback(String name, Runnable callback, int scope); Object resolveReference(String key); String getSessionId(); Object getSessionMutex();} RequestAttributes 是用于访问与请求关联的属性对象接口，主要用于操作与请求关联的属性，支持访问 request 作用域和 session作用域的属性。 ServletRequestAttributes 是 RequestAttributes 的一个实现类， 123456789101112131415161718@Overridepublic void setAttribute(String name, Object value, int scope) { // 如请求是reqeust作用域，将属性设置到HttpServletRequest中 if (scope == SCOPE_REQUEST) { // 判断当前请求是否还没有处理，如果已经处理完成则抛出异常 if (!isRequestActive()) { throw new IllegalStateException( \"Cannot set request attribute - request is not active anymore!\"); } this.request.setAttribute(name, value); } // 请求为session作用域，将属性设置到HttpSession中 else { HttpSession session = obtainSession(); this.sessionAttributesToUpdate.remove(name); session.setAttribute(name, value); }} isRequestActive 方法判断当前请求是否没有处于激活状态，激活状态表示请求还没有处理 12345private volatile boolean requestActive = true;protected final boolean isRequestActive() { return this.requestActive;} 当请求处理完成后会将 requestActive 设置为false 123456public void requestCompleted() { // 如果执行回调 executeRequestDestructionCallbacks(); updateAccessedSessionAttributes(); this.requestActive = false;} DispatcherServlet.doService方法doService(HttpServletRequest request, HttpServletResponse response) 方法是 FrameworkServlet 提供给子类处理请求的模板方法，doService 方法是 DispatcherServlet 中的入口方法，doServcie 方法没有执行具体的处理工作，而是交给 doDispatcher 方法完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { logRequest(request); Map attributesSnapshot = null; // 当include请求时对request的属性做备份 if (WebUtils.isIncludeRequest(request)) { attributesSnapshot = new HashMap(); Enumeration attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) { String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) { attributesSnapshot.put(attrName, request.getAttribute(attrName)); } } } // 设置request的属性，如Web上下文、本地化解析器、主题解析器、主题源 request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); // 重定向传递参数 if (this.flashMapManager != null) { FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) { request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); } request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); } try { // 调用doDispatch方法处理请求 doDispatch(request, response); } finally { if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // 如果是include请求，那么清除request备份的属性 if (attributesSnapshot != null) { restoreAttributesAfterInclude(request, attributesSnapshot); } } }} DispatcherServlet.doDispatch方法DispactherServlet 处理请求返回响应流程在 doDispatcher 方法，doDispatch 方法的主要任务为： 根据 request 找到对应的 Handler（使用@Controller注解标注的类） 将 handler 包装为 HandlerAdapter 用 HandlerAdapter 处理 Handler 调用 processDispatcherResult 方法处理之后的结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; // 上传请求标识 boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; // 记录内层异常 Exception dispatchException = null; try { // 1.检查请求是否是multipart（文件上传），如果是则使用MultipartResolver解析 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); /** * 2.根据request找到HandlerExecutionChain， * 请求到处理器/页面控制器的映射，通过HandlerMapping进行映射 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) { noHandlerFound(processedRequest, response); return; } // 3.将andler包装为HandlerAdapter（处理器适配） // 将处理器包装成相应的适配器，从而支持多种类型的处理器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 4.处理GET、HEAD请求的Last-Modified String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request,response) .checkNotModified(lastModified) && isGet) { return; } } // 5.执行处理器相关的拦截器的预处理preHandle if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } // 6.由适配器执行处理器，调用处理器相应的功能处理方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); // 如果需要异步处理直接返回 if (asyncManager.isConcurrentHandlingStarted()) { return; } // 7.如果view为空，根据request设置默认view applyDefaultViewName(processedRequest, mv); // 8.执行处理器相关的拦截器的后处理postHandle mappedHandler.applyPostHandle(processedRequest, response, mv); } // 内层异常处理 catch (Exception ex) { dispatchException = ex; } catch (Throwable err) { dispatchException = new NestedServletException( \"Handler dispatch failed\", err); } // 9.处理返回结果：包括异常处理、渲染视图、发出完成通知触发Interceptor的afterCompleion processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); } // 外层异常处理：processDispatchResult 方法抛出的异常 catch (Exception ex) { triggerAfterCompletion(processedRequest, response, mappedHandler, ex); } catch (Throwable err) { triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); } finally { // 判断是否执行异步请求 if (asyncManager.isConcurrentHandlingStarted()) { if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted( processedRequest, response); } } else { // 如果是上传文件请求则删除上传请求的数据 if (multipartRequestParsed) { cleanupMultipart(processedRequest); } } }} doDispatcher 方法主要作用是 处理请求和渲染视图，主要流程流程为： 1、检查是否是上传请求，如果是上传请求，将 request 转换为 MultiHttpServletRequest，并将上传请求标识 multipartRequestParsed 设置为 true； 2、根据 request 找到 HandlerMapping处理请求，返回一个处理器链：HandlerExecutionChain； 3、将handler包装为HandlerAdapter 4、处理 GET/POST 方法的 Last-Modification； 5、执行 HandlerExecutionChain#preHandler方法 6、HandlerAdapter调用处理器相应的功能处理方法 7、判断是否需要异步处理，如果是异步请求，则直接返回，不再执行后续过程； 8、如果 HanlderAdapter 处理请求完后返回为空，则设置默认的视图名； 9、调用 processDispatchResult 方法处理前面步骤返回的结果，包含异常处理、视图渲染、触发 Interceptor 的afterCompleion 方法发出请求处理完成通知。 检查上传请求123456789101112131415161718192021222324252627282930313233343536private MultipartResolver multipartResolver;protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException { // if (this.multipartResolver != null && this.multipartResolver.isMultipart(request)) { if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) { if (request.getDispatcherType().equals(DispatcherType.REQUEST)) { logger.trace(\"Request already resolved to\" +\" MultipartHttpServletRequest, e.g. by MultipartFilter\"); } } else if (hasMultipartException(request)) { logger.debug(\"Multipart resolution previously failed for current\" + \" request - skipping re-resolution for\" + \" undisturbed error rendering\"); } else { try { return this.multipartResolver.resolveMultipart(request); } catch (MultipartException ex) { if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) { logger.debug(\"Multipart resolution failed for error dispatch\", ex); // Keep processing error dispatch with regular request handle below } else { throw ex; } } } } // If not returned before: return original request. return request;} MultipartResolver 是处理上传请求的策略类，在 Spring MVC 配置的默认策略类中并不包含 MultipartSolver， 根据request找到HandlerMapping1234567891011121314private List handlerMappings;protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { // 如果handlerMappings不为空，则遍历所有HandlerMapping，找到合适的HandlerMapping处理 if (this.handlerMappings != null) { for (HandlerMapping mapping : this.handlerMappings) { HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) { return handler; } } } return null;} Spring MVC 默认会配置 BeanNameUrlHandlerMapping、RequestMappingHandlerMapping 两个 HandlerMapping，HandlerMapping 执行后返回一个 HandlerExecutionChain 对象；HandlerExecutionChain 包含多个拦截器 Interceptor 和一个处理器 handler；执行时先执行 Interceptor 的 preHandler方法，然后执行 handler 的处理方法；返回时先执行 Interceptor 的 postHandler 方法。 将handler包装为HandlerAdapter123456789101112131415private List handlerAdapters;protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException { if (this.handlerAdapters != null) { // 遍历所有HandlerAdapter，判断谁支持处理handler，则返回该HandlerAdapter for (HandlerAdapter adapter : this.handlerAdapters) { if (adapter.supports(handler)) { return adapter; } } } throw new ServletException(\"No adapter for handler [\" + handler + \"]: The\" + \" DispatcherServlet configuration needs to include\" + \" a HandlerAdapter that supports this handler\");} Spring MVC 默认会配置 HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter、RequestMappingHandlerAdapter 三个 HadnlerAdapter；将 hanlder 包装为 HandlerAdapter。 处理 GET/POST 方法的 Last-Modification1234567891011// 处理GET、HEAD请求的Last-ModifiedString method = request.getMethod();boolean isGet = \"GET\".equals(method);if (isGet || \"HEAD\".equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request,response) .checkNotModified(lastModified) && isGet) { return; }} 当浏览器第一访问服务器的请求资源时，服务器会在返回响应的响应头中增加一个 Last-Modification 属性，表示该资源最后什么时候修改的；浏览器再次访问该资源时，会发送之前接收到 的 Last-Modification 属性给服务器，服务器收到带 Last-Modification 属性的请求后，与资源实际修改时间进行对比，如果资源过期则返回新的资源，同时返回新的 Last-Modification 属性；如果资源没有过期，直接返回 304 状态码，表示资源没有过期，浏览器收到 304 状态码后直接使用缓存的结果。 执行 HandlerExecutionChain#preHandler方法123if (!mappedHandler.applyPreHandle(processedRequest, response)) { return;} HandlerExecutionChain#applyPreHandler 方法为： 1234567891011121314151617181920212223boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception { HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) { /** * 遍历所有的拦截器HandlerInterceptor，执行preHandler方法， * 每个拦截器都可以决定中止执行链，通常发送HTTP错误或编写自定义响应 */ for (int i = 0; i < interceptors.length; i++) { HandlerInterceptor interceptor = interceptors[i]; /** * 如果终止拦截器拦截或者执行完最后一个handler本身(我们书写的Controller), * 则触发所有拦截器triggerAfterCompletion */ if (!interceptor.preHandle(request, response, this.handler)) { triggerAfterCompletion(request, response, null); return false; } this.interceptorIndex = i; } } return true;} HandlerExecutionChain#triggerAfterCompletion 方法为： 12345678910111213141516171819void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex) throws Exception { HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) { /** * 遍历所有的拦截器HandlerInterceptor，执行afterCompletion方法,表示该拦截器处理完请求 */ for (int i = this.interceptorIndex; i >= 0; i--) { HandlerInterceptor interceptor = interceptors[i]; try { interceptor.afterCompletion(request, response, this.handler, ex); } catch (Throwable ex2) { logger.error(\"HandlerInterceptor.afterCompletion threw exception\", ex2); } } }} HandlerAdapter调用handler的功能处理方法1mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 拦截器执行 preHandler 方法后，就是调用 HandlerAdapter.handle 方法处理请求，返回 ModelAndView，这就是我们书写的 Controller 在这里执行。 HttpRequestHandlerAdapter 处理请求： 12345678910111213141516171819202122232425public class HttpRequestHandlerAdapter implements HandlerAdapter { @Override public boolean supports(Object handler) { return (handler instanceof HttpRequestHandler); } @Override @Nullable public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { ((HttpRequestHandler) handler).handleRequest(request, response); return null; } @Override public long getLastModified(HttpServletRequest request, Object handler) { if (handler instanceof LastModified) { return ((LastModified) handler).getLastModified(request); } return -1L; }} SimpleControllerHandlerAdapter 处理请求： 123456789101112131415161718192021222324public class SimpleControllerHandlerAdapter implements HandlerAdapter { @Override public boolean supports(Object handler) { return (handler instanceof Controller); } @Override @Nullable public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return ((Controller) handler).handleRequest(request, response); } @Override public long getLastModified(HttpServletRequest request, Object handler) { if (handler instanceof LastModified) { return ((LastModified) handler).getLastModified(request); } return -1L; }} SimpleServletHandlerAdapter 处理请求： 12345678910111213141516171819202122public class SimpleServletHandlerAdapter implements HandlerAdapter { @Override public boolean supports(Object handler) { return (handler instanceof Servlet); } @Override @Nullable public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { ((Servlet) handler).service(request, response); return null; } @Override public long getLastModified(HttpServletRequest request, Object handler) { return -1; }} 最后还有 AbstractHandlerMethodAdapter 的子类，它有一个实现类 RequestMappingHandlerAdapter，在 AbstractHandlerMethodAdapter 内部，把请求的处理交给子类重写的 handleInternal 方法来实现： 12345678910public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return handleInternal(request, response, (HandlerMethod) handler);}@Nullableprotected abstract ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception; 异步执行1234// 如果需要异步处理直接返回if (asyncManager.isConcurrentHandlingStarted()) { return;} 这一步就是判断请求是否需要异步执行，如果需要异步执行，则返回。如果不需要异步处理则进行下一步处理。 其中 WebAsyncManager#isConcurrentHandlingStarted 方法为： 12345private AsyncWebRequest asyncWebRequest;public boolean isConcurrentHandlingStarted() { return (this.asyncWebRequest != null && this.asyncWebRequest.isAsyncStarted());} 设置默认视图名如果 HanlderAdapter 处理请求完后返回为空，也就是 view 为空，则调用 applyDefaultViewName 方法设置默认视图。 123456789private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception { if (mv != null && !mv.hasView()) { String defaultViewName = getDefaultViewName(request); if (defaultViewName != null) { mv.setViewName(defaultViewName); } }} 执行 HandlerExecutionChain#postHandler方法123456789101112131415void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception { HandlerInterceptor[] interceptors = getInterceptors(); /** * 遍历所有HandlerInterceptor，调用postHandle方法处理请求 * 遍历HandlerInterceptor的顺序与preHandle方法的顺序相反 */ if (!ObjectUtils.isEmpty(interceptors)) { for (int i = interceptors.length - 1; i >= 0; i--) { HandlerInterceptor interceptor = interceptors[i]; interceptor.postHandle(request, response, this.handler, mv); } }} 执行 processDispatchResult 方法processDispatchResult 方法处理返回结果：包括异常处理、渲染视图、触发 HandlerInterceptor 拦截器的 afterCompleion 方法发出请求处理完成通知。 doDispatch 有两层异常结构：内层捕获在对请求进行处理过程中抛出的异常；外层是在处理渲染视图时抛出的异常；也就是以 processDispatchResult 方法为分界线，内层异常会记录到 dispatchException 变量中，外层异常是指定 processDispatchResult 方法抛出的异常； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception { boolean errorView = false; // 如果内层异常不为空，也就是处理请求过程中抛出异常，则处理异常，将异常信息设置到视图中 if (exception != null) { if (exception instanceof ModelAndViewDefiningException) { logger.debug(\"ModelAndViewDefiningException encountered\", exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); } else { Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); } } // 渲染视图 if (mv != null && !mv.wasCleared()) { render(mv, request, response); if (errorView) { WebUtils.clearErrorRequestAttributes(request); } } else { if (logger.isTraceEnabled()) { logger.trace(\"No view rendering, null ModelAndView returned.\"); } } // 如果是异步处理则直接返回 if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Concurrent handling started during a forward return; } /** * 如果handlerExecutionChain不为空，则触发HandlerInterceptor#afterCompletion方法 * 发出请求处理完成通知 */ if (mappedHandler != null) { mappedHandler.triggerAfterCompletion(request, response, null); }} 渲染视图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception { // 获取response对应Locale Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); // 设置reponse的Locale response.setLocale(locale); View view; // 获取视图名 String viewName = mv.getViewName(); // 如果视图名不为空，根据视图名解析视图 if (viewName != null) { view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) { throw new ServletException(\"Could not resolve view with name '\" + mv.getViewName() + \"' in servlet with name '\" + getServletName() + \"'\"); } } // 如果视图名为空，则设置 else { // 获取视图 view = mv.getView(); if (view == null) { throw new ServletException(\"ModelAndView [\" + mv + \"] neither contains a\" + \" view name nor a View object in servlet with name '\" + getServletName() + \"'\"); } } if (logger.isTraceEnabled()) { logger.trace(\"Rendering view [\" + view + \"] \"); } try { // 设置response的响应码 if (mv.getStatus() != null) { response.setStatus(mv.getStatus().value()); } // 根据模型数据渲染图 view.render(mv.getModelInternal(), request, response); } catch (Exception ex) { if (logger.isDebugEnabled()) { logger.debug(\"Error rendering view [\" + view + \"]\", ex); } throw ex; }} 触发请求处理完成通知12345678910111213141516171819void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex) throws Exception { HandlerInterceptor[] interceptors = getInterceptors(); /** * 遍历所有HandlerInterceptor，执行每个拦截器的afterCompletion方法 * 从后向前遍历每个HandlerInterceptor */ if (!ObjectUtils.isEmpty(interceptors)) { for (int i = this.interceptorIndex; i >= 0; i--) { HandlerInterceptor interceptor = interceptors[i]; try { interceptor.afterCompletion(request, response, this.handler, ex); } catch (Throwable ex2) { logger.error(\"HandlerInterceptor.afterCompletion threw exception\", ex2); } } }} 需要注意的是：触发拦截器 afterCompletion 方法的顺序与执行拦截器preHandle方法的顺序相反； 处理请求总体流程1、用户发送请求 –> DispatcherServlet：前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制； 2、DispatcherServlet –> HandlerMapping（默认为 BeanNameUrlHandlerMapping）：HandlerMapping 把请求映射成 HandlerExecutionChain 对象（包含一个 Hadnler 处理器对象、多个 HandlerInterceptor 拦截器对象），通过策略模式很容易添加新的映射策略； 3、DispatcherServlet –> HandlerAdapter（默认为 SimpleControllerHandlerAdapter）：HandlerAdapter 把处理器包装成适配器，从而支持多种类型的处理器，这里是使用适配器模式来支持多种类型的处理器； 4、HandlerAdapter –> 调用处理器（Controller 接口的实现类）功能处理方法（ ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) ）：HandlerAdapter 将会根据适配的结果调用真正的处理器功能处理方法，完成功能处理，并返回一个 ModelAndView 对象；ModelAndView 对象包含模型数据和逻辑视图名； 5、ModelAndView 逻辑视图名 –> ViewResolver（默认为 InternalResourceViewResolver）：ViewResolver 把逻辑视图名解析为具体的视图 View，也是通过策略模式实现，可以方便更换视图技术； 6、View （默认为 JstlView）–> 渲染：View 根据传递进来的 Model 模型数据进行渲染，Model 其实就是一个 Map 的数据结构，因此容易支持其他视图技术； 7、返回控制权给 DispatcherServlet，DispatcherServlet 返回响应给用户，结束请求-响应模型。 从上面的流程可以看出，SpringMVC 处理请求的核心工作为： 1、DispatcherServlet 在 web.xml 中部署描述，从而拦截请求到 SpringMVC； 2、HandlerMapping 的配置，从而将请求映射到处理器； 3、HandlerAdapter的配置，从而支持多种类型处理器； 4、ViewResolver配置，从而逻辑视图名解析具体的视图； 5、处理器配置：进行功能处理。 总结HttpServletBean在 Web 容器启动时将调用 init 方法，将 DispatcherServlet 初始化参数（init-param）使用 BeanWrapper 设置到 DispatcherServlet 组件上，在初始化时将 DispatcherServlet 中的 标签的 子标签当做一个 bean；然后调用 HttpServletBean 的模板方法 initServletBean 初始化 Servlet； FrameworkServlet：初始化通过重写父类 HttpServletBean 的 initServletBean 方法在完成 Servlet 的初始化，在 initServletBean 方法中主要做了两件事： （1）创建由 DispatcherServlet 加载的 WebApplicationContext，并设置它的父容器：由 ContextLoaderListener 加载的根容器，以及完成容器的其他初始化，同时提供 onRefresh 模板方法来完成容器的刷新工作； （2）定义 initFrameworkServlet 模板方法，默认为空，由子类重写实现特定的初始化需求； 处理请求1、在 service 方法中增加对 HTTP PATCH 方法的支持；如果为 PATCH 请求则将请求交给 processRequest 方法直接处理，否则为其他类型的请求，则把请求交给父类 HttpServlet#service 方法处理；而 HttpServlet#service 方法会根据请求类型把请求的处理交给 FrameworkServlet#doXxx 方法， 2、FrameworkServlet 在 doXxx 方法大部分是将请求的处理统一交给 processRequest 方法处理，也就是说将不同类型的请求处理都合并到 processRequest 方法中，在 processRequest 方法主要做了如下三件事： （1）将当前请求的 LocaleContext、ServletRequestAttributes 在处理请求前设置到 LocaleConetxtHolder、RequestContextHolder 中，在处理完后恢复； （2）调用模板方法 doService 方法处理请求，doService 是在 DispatcherServlet 中实现； （3）请求处理完成后发布 ServletRequestHandledEvent 事件； DispatcherServletDispatcherServlet#doService 方法完成请求的具体处理工作， （1）首先对请求设置一些属性，比如当请求为 include 请求时，对当前 request 的属性进行备份；然后将当前的 web上下文、本地化解析器、主题解析器、主题源设置为 request 的属性保存下来，设置 FlashMap 解决重定向时数据传输问题； （2）把请求交给 doDispatcher 方法处理； doDispatcher 方法时完成请求处理的具体方法，这其中涉及都如下九个步骤： 1、检查是否是上传请求，如果是上传请求，将 request 转换为 MultiHttpServletRequest，并将上传请求标识 multipartRequestParsed 设置为 true； 2、根据 request 找到 HandlerMapping处理请求，返回一个处理器链：HandlerExecutionChain； 3、将handler包装为HandlerAdapter 4、处理 GET/POST 方法的 Last-Modification； 5、执行 HandlerExecutionChain#preHandler方法 6、HandlerAdapter调用处理器相应的功能处理方法 7、判断是否需要异步处理，如果是异步请求，则直接返回，不再执行后续过程； 8、如果 HanlderAdapter 处理请求完后返回为空，则设置默认的视图名； 9、调用 processDispatchResult 方法处理前面步骤返回的结果，包含异常处理、视图渲染、触发 Interceptor 的afterCompleion 方法发出请求处理完成通知。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"Java序列化","slug":"Java序列化","date":"2019-07-20T09:10:35.000Z","updated":"2019-07-20T10:20:49.147Z","comments":true,"path":"2019/07/20/Java序列化/","link":"","permalink":"http://yoursite.com/2019/07/20/Java序列化/","excerpt":"","text":"序列化 在远程调用中，需要把参数和返回值通过网络传输，这时就要用到序列化将对象转变成字节流，从一端到另一端之后再反序列化回来变成对象，因此，我们需要先了解一下序列化和反序列化。 序列化(Serialization)：也称为编码(Encode)，将对象序列化为字节数组，用于网络传输、数据持久化等用途； 反序列化(Deserialization)：也称为解码(Decode)，负责从网络、磁盘中读取的字节数组还原成原始对象（通常是原始对象的副本）。 Java 默认序列化机制Java 提供默认的序列化机制，需要序列化的对象只需要实现 java.io.Serializable 接口并生成序列化 ID，这个类就可以通过 java.io.ObjectInput 和 java.io.ObjectOutput 序列化和反序列。也可以通过 Externalizable 接口实现序列化和反序列化 一旦某个类实现了 Serializable 接口，那么这个类就是可序列化的，可以通过 ObjectOutputStream 来序列化对象： 12345Person person = new Person();ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"object.txt\"));outputStream.writeObject(object); 如果希望从二进制流中恢复对象，则需要通过 ObjectInputStream 来反序列化 1234ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"object.txt\"));Person person = (Person)inputStream.readObject(); 如果使用序列化机制向文件写入多个 Java 对象，在使用反序列化机制恢复对象时必须按照实际写入的顺序读取。 当一个可序列化类由多个父类时，这些父类要么有无参构造方法，要么也是可序列化的，否则就会抛出 InvalidClassException，如果这个父类时不可序列化的，只是带无参构造方法，则该父类中定义的成员变量值不会序列化到二进制流中。 Java 序列化算法Java 序列化采用一种特殊的算法，具有如下特点： 所有保存到磁盘的对象都要一个序列化编号； 当程序视图序列化一个对象时，程序首先检查该对象是否已经序列化过，只有该对象从未被序列化，系统才会将该对象转换为字节序列输出； 如果某个对象已经序列化过，程序将直接输出一个序列化编号，而不是再次重新序列化该对象； 递归序列化： 当对某个对象进行序列化，系统会自动把该对象的所有实例变量进行序列化，如果某个实例变量引用另外一个对象，则被引用的对象也会被序列化，如果被引用的对象实例变量也引用了其他对象，则被引用的对象也会被序列化，这种情况就称为递归序列化。 transient 关键字在某些特殊场景，比如在一个类中包含的某些实例变量是敏感信息，如银行账户信息等，那么可以在该实例变量前增加 transient 关键字，那么 Java 序列化机制就会在序列化时不会序列化该变量。 1234567891011121314151617public class Person implements Serializable { private String name; private int age; private transient String phone; public Person(String name, int age, String phone) { System.out.println(\"Person 构造方法\"); this.name = name; this.age = age; this.phone = phone; } // 省略getter/setter方法} 1234567891011121314public static void main(String[] args) { try (ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(\"E:/download/transient.txt\")); ObjectInputStream ois = new ObjectInputStream( new FileInputStream(\"E:/download/transient.txt\"))) { Person person = new Person(\"xiaoxiao\", 20, \"18200594087\"); oos.writeObject(person); person = (Person)ois.readObject(); // 输出null System.out.println(person.getPhone()); } catch (Exception e) { e.printStackTrace(); } } 需要注意的是：transient 关键字只能修饰实例变量，不可修饰 Java 程序中的其他部分； 自定义序列化机制transient 关键字修饰的实例变量被完全隔离在序列化机制之外，这就导致在反序列化恢复 Java 对象时无法获取该实例变量值。 Java 提供了另外一种自定义序列化机制，通过重写如下方法： private void writeObject(ObjectOutputStream out) throws IOException private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException private void readObjectNoData() throws ObjectStreamException 通过重写上面三个方法，可以让程序控制如何序列化实例变量，甚至可以达到 transient 关键字不序列化某个字段的效果。 默认情况下，使用 ObjectOutputStream.defaultWriteObject() 方法来保存各个对象的实例变量，从而实现序列化 Java 对象状态的目的，writeObject 方法负责写入特定类的实例状态，通过重写 writeObject 方法可以实现序列化机制的控制； 默认情况下，使用ObjectInputStream.defaultReadObject() 方法从二进制流中读取对象的实例变量，从而实现反序列化机制；readObject 方法负责从流中读取并恢复对象的实例变量，通过重写 readObject 方法来恢复对象的非 transient 实例变量。 当序列化流不完整时，readObjectNoData 方法可以正确地初始化反序列化的对象。 Externalizable 接口除了实现 Serializable 接口外，还可以实现 Externalizable 接口来支持序列化和反序列化。 1234567891011public interface Externalizable extends java.io.Serializable { /** * 实现序列化的方法，调用ObjectOutput.writeObject */ void writeExternal(ObjectOutput out) throws IOException; /** * 实现反序列化的方法，调用ObjectInput.readObject方法 */ void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;} 序列化总结： 对象名、实例变量都会被序列化 方法、类变量、transient 变量都不会被序列化 实现 Serializable 接口的类如果想要某个实例变量不被序列化，那么可以使用 transient 关键字修饰该变量； Hessian序列化机制Hessian 序列化比 Java 序列化高效很多，而且生成的字节流也要短很多。但相对来说没有 Java 序列化可靠，而且也不如 Java序列化支持的全面，主要在于他们的实现方式不同： Java 序列化会把要序列化的对象类的元数据和业务数据全部序列化为字节流，而且是把整个继承关系上的东西全部序列化了。它序列化出来的字节流是对那个对象结构到内容的完全描述，包含所有的信息，因此效率较低而且字节流比较大。但是由于确实是序列化了所有内容，所以可以说什么都可以传输，因此也更可用和可靠。 Hessian序列化，它的实现机制是着重于数据，附带简单的类型信息的方法。就像Integer a = 1，Hessian会序列化成I 1这样的流，I表示int or Integer，1就是数据内容。而对于复杂对象，通过Java的反射机制，Hessian把对象所有的属性当成一个Map来序列化，包含了基本的类型描述和数据内容。而在序列化过程中，如果一个对象之前出现过，Hessian会直接插入一个R index这样的块来表示一个引用位置，从而省去再次序列化和反序列化的时间。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-20T07:50:55.525Z","updated":"2019-07-20T09:42:23.112Z","comments":true,"path":"2019/07/20/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}