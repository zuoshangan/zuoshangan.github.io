{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"zuoshangan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-07-20T09:35:47.000Z","updated":"2019-07-20T09:52:53.466Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"SpringMVC","date":"2019-08-03T12:32:50.000Z","updated":"2019-08-03T12:32:50.591Z","comments":true,"path":"SpringMVC/index.html","permalink":"http://yoursite.com/SpringMVC/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"archives","date":"2019-07-20T09:36:02.000Z","updated":"2019-07-20T09:36:02.060Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-07-20T09:35:30.000Z","updated":"2019-07-20T09:53:18.136Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-07-20T09:35:36.000Z","updated":"2019-07-20T09:53:10.380Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Java序列化","slug":"Java序列化","date":"2019-07-20T09:10:35.000Z","updated":"2019-07-20T10:20:49.147Z","comments":true,"path":"2019/07/20/Java序列化/","link":"","permalink":"http://yoursite.com/2019/07/20/Java序列化/","excerpt":"","text":"序列化 在远程调用中，需要把参数和返回值通过网络传输，这时就要用到序列化将对象转变成字节流，从一端到另一端之后再反序列化回来变成对象，因此，我们需要先了解一下序列化和反序列化。 序列化(Serialization)：也称为编码(Encode)，将对象序列化为字节数组，用于网络传输、数据持久化等用途； 反序列化(Deserialization)：也称为解码(Decode)，负责从网络、磁盘中读取的字节数组还原成原始对象（通常是原始对象的副本）。 Java 默认序列化机制Java 提供默认的序列化机制，需要序列化的对象只需要实现 java.io.Serializable 接口并生成序列化 ID，这个类就可以通过 java.io.ObjectInput 和 java.io.ObjectOutput 序列化和反序列。也可以通过 Externalizable 接口实现序列化和反序列化 一旦某个类实现了 Serializable 接口，那么这个类就是可序列化的，可以通过 ObjectOutputStream 来序列化对象： 12345Person person = new Person();ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"object.txt\"));outputStream.writeObject(object); 如果希望从二进制流中恢复对象，则需要通过 ObjectInputStream 来反序列化 1234ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"object.txt\"));Person person = (Person)inputStream.readObject(); 如果使用序列化机制向文件写入多个 Java 对象，在使用反序列化机制恢复对象时必须按照实际写入的顺序读取。 当一个可序列化类由多个父类时，这些父类要么有无参构造方法，要么也是可序列化的，否则就会抛出 InvalidClassException，如果这个父类时不可序列化的，只是带无参构造方法，则该父类中定义的成员变量值不会序列化到二进制流中。 Java 序列化算法Java 序列化采用一种特殊的算法，具有如下特点： 所有保存到磁盘的对象都要一个序列化编号； 当程序视图序列化一个对象时，程序首先检查该对象是否已经序列化过，只有该对象从未被序列化，系统才会将该对象转换为字节序列输出； 如果某个对象已经序列化过，程序将直接输出一个序列化编号，而不是再次重新序列化该对象； 递归序列化： 当对某个对象进行序列化，系统会自动把该对象的所有实例变量进行序列化，如果某个实例变量引用另外一个对象，则被引用的对象也会被序列化，如果被引用的对象实例变量也引用了其他对象，则被引用的对象也会被序列化，这种情况就称为递归序列化。 transient 关键字在某些特殊场景，比如在一个类中包含的某些实例变量是敏感信息，如银行账户信息等，那么可以在该实例变量前增加 transient 关键字，那么 Java 序列化机制就会在序列化时不会序列化该变量。 1234567891011121314151617public class Person implements Serializable { private String name; private int age; private transient String phone; public Person(String name, int age, String phone) { System.out.println(\"Person 构造方法\"); this.name = name; this.age = age; this.phone = phone; } // 省略getter/setter方法} 1234567891011121314public static void main(String[] args) { try (ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(\"E:/download/transient.txt\")); ObjectInputStream ois = new ObjectInputStream( new FileInputStream(\"E:/download/transient.txt\"))) { Person person = new Person(\"xiaoxiao\", 20, \"18200594087\"); oos.writeObject(person); person = (Person)ois.readObject(); // 输出null System.out.println(person.getPhone()); } catch (Exception e) { e.printStackTrace(); } } 需要注意的是：transient 关键字只能修饰实例变量，不可修饰 Java 程序中的其他部分； 自定义序列化机制transient 关键字修饰的实例变量被完全隔离在序列化机制之外，这就导致在反序列化恢复 Java 对象时无法获取该实例变量值。 Java 提供了另外一种自定义序列化机制，通过重写如下方法： private void writeObject(ObjectOutputStream out) throws IOException private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException private void readObjectNoData() throws ObjectStreamException 通过重写上面三个方法，可以让程序控制如何序列化实例变量，甚至可以达到 transient 关键字不序列化某个字段的效果。 默认情况下，使用 ObjectOutputStream.defaultWriteObject() 方法来保存各个对象的实例变量，从而实现序列化 Java 对象状态的目的，writeObject 方法负责写入特定类的实例状态，通过重写 writeObject 方法可以实现序列化机制的控制； 默认情况下，使用ObjectInputStream.defaultReadObject() 方法从二进制流中读取对象的实例变量，从而实现反序列化机制；readObject 方法负责从流中读取并恢复对象的实例变量，通过重写 readObject 方法来恢复对象的非 transient 实例变量。 当序列化流不完整时，readObjectNoData 方法可以正确地初始化反序列化的对象。 Externalizable 接口除了实现 Serializable 接口外，还可以实现 Externalizable 接口来支持序列化和反序列化。 1234567891011public interface Externalizable extends java.io.Serializable { /** * 实现序列化的方法，调用ObjectOutput.writeObject */ void writeExternal(ObjectOutput out) throws IOException; /** * 实现反序列化的方法，调用ObjectInput.readObject方法 */ void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;} 序列化总结： 对象名、实例变量都会被序列化 方法、类变量、transient 变量都不会被序列化 实现 Serializable 接口的类如果想要某个实例变量不被序列化，那么可以使用 transient 关键字修饰该变量； Hessian序列化机制Hessian 序列化比 Java 序列化高效很多，而且生成的字节流也要短很多。但相对来说没有 Java 序列化可靠，而且也不如 Java序列化支持的全面，主要在于他们的实现方式不同： Java 序列化会把要序列化的对象类的元数据和业务数据全部序列化为字节流，而且是把整个继承关系上的东西全部序列化了。它序列化出来的字节流是对那个对象结构到内容的完全描述，包含所有的信息，因此效率较低而且字节流比较大。但是由于确实是序列化了所有内容，所以可以说什么都可以传输，因此也更可用和可靠。 Hessian序列化，它的实现机制是着重于数据，附带简单的类型信息的方法。就像Integer a = 1，Hessian会序列化成I 1这样的流，I表示int or Integer，1就是数据内容。而对于复杂对象，通过Java的反射机制，Hessian把对象所有的属性当成一个Map来序列化，包含了基本的类型描述和数据内容。而在序列化过程中，如果一个对象之前出现过，Hessian会直接插入一个R index这样的块来表示一个引用位置，从而省去再次序列化和反序列化的时间。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-20T07:50:55.525Z","updated":"2019-07-20T09:42:23.112Z","comments":true,"path":"2019/07/20/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}